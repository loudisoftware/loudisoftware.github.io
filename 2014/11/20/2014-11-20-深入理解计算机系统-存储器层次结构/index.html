<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="描述存储器的层次结构,存储技术,以及存储结构对对程序性能的影响.">
<meta property="og:type" content="article">
<meta property="og:title" content="存储器层次结构">
<meta property="og:url" content="http://example.com/2014/11/20/2014-11-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="WJAINNG">
<meta property="og:description" content="描述存储器的层次结构,存储技术,以及存储结构对对程序性能的影响.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%981.jpg">
<meta property="og:image" content="http://example.com/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%982.jpg">
<meta property="og:image" content="http://example.com/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%983.jpg">
<meta property="og:image" content="http://example.com/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%984.jpg">
<meta property="og:image" content="http://example.com/images/%E5%91%BD%E4%B8%AD1.jpg">
<meta property="article:published_time" content="2014-11-19T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-19T08:22:15.870Z">
<meta property="article:author" content="wjainng">
<meta property="article:tag" content="深入理解计算机系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%981.jpg">

<link rel="canonical" href="http://example.com/2014/11/20/2014-11-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>存储器层次结构 | WJAINNG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WJAINNG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2014/11/20/2014-11-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          存储器层次结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2014-11-20T00:00:00+08:00">2014-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-19 16:22:15" itemprop="dateModified" datetime="2020-09-19T16:22:15+08:00">2020-09-19</time>
              </span>

          
            <div class="post-description">描述存储器的层次结构,存储技术,以及存储结构对对程序性能的影响.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul id="tree" class="ztree"></ul>



<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>&emsp;&emsp;存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备层次结构。CPU寄存器保存着最常用的数据，高速缓存存储器(cache memory)作为相对慢速的主存储器(main memory)中数据和指令的缓冲区域。主存存放存储容量较大，速度较慢的磁盘上的数据。</p>
<p>&emsp;&emsp;CPU寄存器中的数据在0个周期就可以访问，高速缓存需要1-30个周期，主存需要50-200个周期，磁盘上的数据需要几千万个周期。(1GHZ的CPU一个时钟周期为1纳秒)</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p>&emsp;&emsp;磁盘容量以每两年加倍的速度增长。主要包括下面的存储技术。</p>
<h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><p>&emsp;&emsp;随机访问存储器(Random-Access Memory,RAM)分为静态(SRAM)和动态(DRAM)两种。静态比动态块，但是价格也贵很多。SRAM主要用来作为高速缓存存储器，可以在CPU芯片上，或者芯片下。DRAM用来作为主存以及图形系统中的帧缓冲区。SRAM一般只有几兆，但是DRAM为几百或几千兆。</p>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>&emsp;&emsp;SRAM将每一个位存储在一个双稳态的(bistable)存储器单元中。通过一个六晶体管实现，可以无限期保持在两个不同的电压配置或者状态之一。只要有电SRAM就会保持不变，即使有干扰。</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>&emsp;&emsp;DRAM将每一个位存储为对一个电容的充电。DRAM对干扰非常敏感，当电容的电压被扰乱后就永远不会恢复，漏电也会导致电容失去电荷，因此存储器系统必须周期性的通过读取然后重新刷新存储器的每一位。</p>
<p>SRAM与DRAM的对比如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>每位晶体管数</th>
<th>相对访问时间</th>
<th>持续的</th>
<th>敏感的</th>
<th>相对花费</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>SRAM</td>
<td>6</td>
<td>1X</td>
<td>是</td>
<td>否</td>
<td>100X</td>
<td>高速缓存存储器</td>
</tr>
<tr>
<td>DRAM</td>
<td>1</td>
<td>10X</td>
<td>否</td>
<td>是</td>
<td>1X</td>
<td>主存，帧缓冲区</td>
</tr>
</tbody></table>
<h4 id="传统的DRAM"><a href="#传统的DRAM" class="headerlink" title="传统的DRAM"></a>传统的DRAM</h4><p>&emsp;&emsp;DRAM芯片中的位被分成d个超单元(supercell),每一个超单元都由w个DRAM位组成。一个d<em>w的DRAM共存储了dw位信息。超单元被组织成一个r行c列的长方形阵列(r\</em>c=d).每个DRAM芯片被连接到某个称为存储器的电路，这个电路可以一次传送w位到每一个DRAM芯片或一次从每个DRAM芯片传出w位。存储控制器通过先发送行地址(Row Access Strobe,行访问选通脉冲)到DRAM，再发送列地址(Column Access Strobe, 列访问选通脉冲)到DRAM读取对应的数据,而为阵列可以减少芯片的引脚但是需要分两步发送地址，增加了访问时间。</p>
<h4 id="存储器模块"><a href="#存储器模块" class="headerlink" title="存储器模块"></a>存储器模块</h4><p>&emsp;&emsp;DRAM芯片包装在存储器模块(memory module)中，是插到主板的扩展插槽上。常见的有168个引脚的双列直插存储器模块(Dual Inline Memory Module, DIMM)以64位为块传送数据。还有72个引脚的单列直插存储器模块(Single Inline Memory Module, SIMM),以32位为块传送数据。</p>
<h4 id="增强的DRAM"><a href="#增强的DRAM" class="headerlink" title="增强的DRAM"></a>增强的DRAM</h4><p>&emsp;&emsp;有许多种DRAM存储器，为了跟上CPU的速度，会进行优化从而改进访问基本DRAM单元的速度</p>
<ul>
<li>快页模式DRAM(Fast Page Mode DRAM, FPM DRAM).传统的DRAM将超单元的一整行拷贝到它的内部行缓冲区，使用一个，然后丢弃剩余的。FPM DRAM允许对同一行连续地访问可以直接从行缓冲区得到服务。</li>
<li>扩展数据输出DRAM(Extended Data Out DRAM, EDO DRAM).FPM DRAM的一个增强形式，允许单独的CAS信号在时间上靠得更紧密点。</li>
<li>同步DRAM(Synchronous DRAM, SDRAM).其工作速度与系统总线速度同步，速度比FPM DRAM, EDO DRAM快。</li>
<li>双倍数据速率同步DRAM(Double Data-rate Synchronous DRAM, DDR SDRAM).DDR SDRAM是对SDRAM的一种增强，通过两个时钟沿作为控制信号，使得DRAM速度翻倍。不同的DDR SDRAM通过提高有效带宽的很小的预取缓冲区的大小划分DDR(2位)、DDR2(4位)、DDR3(8位)。</li>
<li>Rambus DRAM(RDRAM)是一种私有技术，其最大带宽比DDR SDRAM更高.</li>
<li>视频RAM(Video RAM, VRAM).用在图形系统的帧缓冲区中。VRAM思想与FPM DRAM类似。主要有下面的区别:1)VRAM的输出是通过依次对内部缓冲区的整个内容移位得到的。2)VRAM允许对存储器并行地读和写。</li>
</ul>
<h4 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h4><p>&emsp;&emsp;如果断电DRAM和SRAM会丢失信息。非易失性存储器(nonvolatile memory)即使在关电后，也保存其信息。由于历史原因，虽然ROM中有的类型既可以读也可以写，但是都称为只读存储器(Read-Only Memory ROM).ROM通过重写的次数和编程的机制进行区分。(存储在ROM设备中的程序通常称为固件[firmware])</p>
<ul>
<li>PROM(Programmable ROM,可编程ROM)只能编程一次。</li>
<li>EPROM(Erasable Programmable ROM,可擦可编程ROM)擦写次数达到1000次。EEPROM(Electrically Erasable Programmable ROM, 电子可擦除PROM)擦写可以达到100000次。</li>
<li>闪存(flash memory),基于EEPROM.</li>
</ul>
<h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p>&emsp;&emsp;磁盘是广为应用的存储设备。从磁盘上读信息的时间为毫秒级。DRAM比磁盘快10万倍，SRAM比磁盘快100万倍。</p>
<h4 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h4><p> &emsp;&emsp;磁盘由盘片(platter)构成。每个盘片有两面或者称为表面(surface),表面覆盖着磁性记录材料。盘片中有一个可以旋转的主轴(spindle),使得盘片以固定的旋转速率(rotational rate)旋转.通常为5400-15000转每分钟(Revolution Per Minute, RPM).磁盘通常包含一个或者多个这样的盘片.<br> &emsp;&emsp;每个表面由一组称为磁道(track)的同心圆组成.每一个磁道被划分成一组扇区(sector)每一个扇区包含相等数量的数据位(通常为512字节).扇区间有一些间隙(gap)分隔开.间隙不存储数据位,用来标识扇区的格式化位.<br> &emsp;&emsp;制造商通常用柱面(cylinder)描述多个盘片驱动器的构造,柱面为盘片表面到主轴中心的距离都相等的磁道的集合.</p>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p> &emsp;&emsp;一个磁盘上可以记录的最大位数为最大容量,由下面的技术因素决定.</p>
<ul>
<li><p>记录密度(recording density 位/英寸):磁道一英寸的段可以放入的位数. </p>
</li>
<li><p>磁道密度(track density 道/英寸):从盘片中心出发一英寸半的段可以有的磁道数.</p>
</li>
<li><p>面密度(areal density 位/平方英寸):记录密度与磁道密度的乘积.</p>
<p>&emsp;&emsp;最初的磁盘,是在面密度比较低的时代设计的,将每一个磁道分为相同的扇区,扇区的数目由最靠内的磁道能记录的扇区数决定.随着面密度的提高,扇区之前的间隙变得不可接受的大,现代的磁盘使用一种称为多区记录(multiple zone recording)的技术,柱面的集合被分割成不想交的子集合,称为记录区(recording zone).每一个区包含一组连续的柱面,区中的每一个柱面的每条磁道都有相同数量的扇区.软盘仍然使用老式的方法,每条磁道的扇区是常数.</p>
</li>
</ul>
<h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p> &emsp;&emsp;磁盘用读/写头(read/writer head)来读写存储在磁性表面的位,读写头连接到一个传动臂(actuator arm)一端.通过沿着半径轴前后移动这个传动臂可以将读写头定位在盘面上的任何磁道上.这个过程称为寻到(seek).有多个盘片的磁盘针对每一个盘面都有一个独立的读写头,所有的读写头都位于同一个柱面上.<br>  &emsp;&emsp;磁盘以扇区大小的块来读写数据,对扇区的访问时间(access time)有三个主要的部分:寻道时间(seek time),旋转时间(rotational latency)和传送时间(transfer time):</p>
<ul>
<li>寻道时间:为了读取某个目标扇区的内容,传动臂首先将读/写头定位到包含目标扇区的磁道上,这个时间称为寻道时间.寻道时间依赖原来的位置和移动速度.通常为3-9ms.</li>
<li>旋转时间:一旦定位到磁道,需要等待目标扇区的第一个位旋转到读/写头下.依赖读/写头到达盘面的位置和磁盘的旋转速度.Tmax rotation = 1/RPM * 60 secs / 1 min,平均旋转时间为最大旋转时间的一半.</li>
<li>传送时间:一个扇区的传送时间依赖旋转速度和每条磁道的扇区数目.平均传送时间如下:Tavg rotation = 1/RPM * 60 secs / 1 min * 1 / (平均扇区数/磁道)<br>&nbsp;</li>
</ul>
<h4 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h4><p> &emsp;&emsp;为了隐藏磁盘构造的复杂性,硬盘中有一个小的硬件/固件设备,称为磁盘控制器维护着逻辑块号和实际(物理)磁盘扇区之间的映射关系.当操作系统需要执行一个I/O操作时,例如读取数据到主存,操作系统发送一个命令到磁盘控制器,让它读取某个逻辑块号,控制器上的固件通过执行一个快速表查找,将逻辑号翻译成一个(盘面,磁道,扇区)的三元组.这个三元组唯一地标识了对应的物理扇区.</p>
<h4 id="连接到I-O设备"><a href="#连接到I-O设备" class="headerlink" title="连接到I/O设备"></a>连接到I/O设备</h4><p> 监视器,鼠标,键盘和磁盘这样的输入/输出(I/O)设备,都是通过I/O中心连接到CPU和主存.I/O总线比系统总线和存储器总线慢,但是可以容纳种类繁多的第三方I/O设备.</p>
<h4 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h4><p> &emsp;&emsp;CPU使用一种称为存储器映射I/O(memory-mapped I/O)的技术向I/O设备发出命令.地址空间有一块地址是为与I/O设备通信保留的.每一个这样的地址称为I/O端口(I/O port).当一个设备连接到总线时,它与一个或多个端口想关联.</p>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>&emsp;&emsp;固态硬盘(Solid State Disk, SSD)是一种基于闪存的存储技术,在某些情况下是传统旋转磁盘极有吸引力的替代产品.-个SSD包含一个或多个闪存芯片和闪存翻译层(flash translation layer)组成.闪存芯片代替传统旋转磁盘中的机械驱动器,闪存翻译层是一个硬件/固件设备,扮演磁盘控制器的角色,将逻辑块翻译成对底层物理设备的访问.<br>一个典型的固态硬盘的性能:</p>
<table>
<thead>
<tr>
<th>读</th>
<th>&nbsp;</th>
<th>写</th>
<th>&nbsp;</th>
</tr>
</thead>
<tbody><tr>
<td>顺序读吞吐量</td>
<td>250MB/s</td>
<td>顺序写吞吐量</td>
<td>170MB/s</td>
</tr>
<tr>
<td>随即读吞吐量</td>
<td>140MB/s</td>
<td>随即写吞吐量</td>
<td>14MB/s</td>
</tr>
<tr>
<td>随即读访问时间</td>
<td>30us</td>
<td>随即写访问时间</td>
<td>300us</td>
</tr>
</tbody></table>
<p>顺序访问时读和写差不多,随机访问时读比写块一个数量级.随机读和写的性能差别是由闪存基本属性决定的.一个闪存由B个块的序列组成,每个块由P页组成.数据以页为单位读写.只有一页所属的块整个被擦除之后,才能写这一页.不过,一旦一个块被擦除,块中的页也可以不需要擦除就能进行写.在大约进行100000次重复写后,块就会损坏,损坏后就不能再使用.随即写很慢的原因:1)擦除块需要相对较长的时间,1ms级别,比访问页所需时间要高一个多数量级.2)如果写操作试图修改一个包含已经有数据的页p,这个块中所有带有用数据的页都必须被拷贝到一个新块,然后才能进行对p的写.闪存翻译中的平均磨损(wear leveling)逻辑视图通过将擦除平均分布在所有的块上来最大化每一个块的寿命.</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>&emsp;&emsp;一个编写良好的计算机程序常常具有良好的局部性(locality).局部性通常有两种不同的形式.</p>
<ul>
<li>时间局部性(temporal locality):被引用过一次的存储器位置很可能在不远的将来再被多次引用.</li>
<li>空间局部性(spatial locality):如果一个存储器位置被引用了一次,那么程序很可能在不远的将来引用附件的一个存储器位置.</li>
</ul>
<p>&emsp;&emsp;有良好局部性的程序比局部性差的程序运行得更快.现代计算机系统的各个层次,从硬件到操作系统,再到应用程序,其设计都利用了局部性.</p>
<h3 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h3><p>&emsp;&emsp;下面的代码对向量的元素求和,这个程序有良好的局部性吗?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumvec</span><span class="params">(<span class="keyword">int</span> v[N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于变量v,函数有很好的空间局部性,但是时间局部性很差,因为每一个元素只访问了一次.对于循环体中的变量,要么有好的空间局部性,要么有好的时间局部性.因此sumvec有良好的局部性.像sumvec中顺序访问每一个元素,为步长为1的引用模式(stride-1 reference pattern).如果每隔k个元素进行访问,称为步长为k的引用模式(strid-k reference pattern).一般而然随着步长的增加,空间局部性下降.例如对一个二维数组进行访问时,先按行再按列访问比先按列再按行访问要好,因为前者的步长为1,后者的步长为一行的元素个数.</p>
<h3 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h3><p>&emsp;&emsp;程序指令也是放在存储器中的,cpu必须读出这些指令,因此可以评价一个程序关于取指令的局部性.循环体中的指令是按照连续的存储器顺序执行的,因此循环具有良好的空间局部性,另外循环体会被执行多次,也具有很好的时间局部性.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>重复引用同一个变量的程序具有良好的时间局部性.</li>
<li>对具有步长为k的引用模式的程序,步长越小,空间局部性越好.</li>
<li>对于取指令来说,循环有好的时间和空间局部性.循环体越小,循环次数越多,局部性越好.</li>
</ul>
<h2 id="存储器层次结构-1"><a href="#存储器层次结构-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>&emsp;&emsp;上面的内容描述了存储技术和计算机软件的一些基本属性,速度较快的存储成本更高容量更小.CPU和主存之间的速度差距在增大,一个编写良好的程序应展示出良好的局部性.硬件和软件的这种相互补充,从存储器的高层往底层走,存储设备变得更慢,更便宜,更大.L0层为少量快速的cpu寄存器,接下来为一个或多个基于SRAM的高速缓存存储器,然后是基于DRAM的主存,接下来为慢速但容量很大的本地磁盘.</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>&emsp;&emsp;高速缓存(cache)是一个小而快的存储设备,作为存储在更大更慢设备的数据对象的缓冲区.对于每一个k,位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存.任何时候第k层的缓存是第k+1层块的一个子集.数据总是可以块大小为传送单元在第k层和k+1层间进行拷贝.一般而言为了弥补底层设备的访问时间,倾向于使用更大的块.</p>
<ol>
<li>缓存命中<br>当程序需要k+1层的某个数据d时,首先在第k层的一个块中查找d,如果d刚好在第k层,则称为缓存命中(cache hit).程序从第k层读取d比从k+1层读取d更快.</li>
<li>缓存不命中<br>如果第k层没有缓存数据对象d,就是缓存不命中(cache miss).当缓存不命中时,第k层需要缓存从第k+1层取出的包含d的那个块,如果第k层的缓存已经满了,可能会覆盖一个现存的块.覆盖一个现存的块的过程称为替换(replacing)或驱逐(evicting)这个块.替换哪个块由缓存替换策略(replacement policy)来控制.</li>
<li>缓存不命中的种类<br>如果第k层的缓存为空,则对任何数据的访问都不会命中,此时为<em>强制性不命中</em>(compulsory miss)或冷不命中(cold miss).冷命中通常是短暂的,等缓存暖身(warmed up)后就不会出现.发生了不命中就需要执行放置策略(placement policy)确定把从第k+1层中取出的块放在哪.最灵活的替换策略是允许放在第k层的任何块中.但是对于用硬件实现时这个策略比较昂贵,因为随即放置块,定位的代价高.这时将会要求第k+1层的某个块限制放在第k层的一个小的子集中.这种限制性的放置策略会引起<em>冲突不命中</em>(conflict miss),此时缓存足够大,但是因为这些对象映射到同一个缓存块,导致缓存不命中.当缓存太少导致的不命中称为<em>容量不命中</em>(capalicity miss),例如一个循环可能会反复访问一个数组元素,但是当数组的大小超过缓存的大小时就会出现.</li>
<li>缓存管理<br>编译器管理寄存器文件,缓存层次结构的最高层.L1,L2,L3层的缓存由内置在缓存中的硬件逻辑管理.DRAM主存由操作系统和CPU上的地址翻译硬件共同管理.</li>
<li>总结<br>存储结构能有效主要因为程序表现局部性.时间局部性和空间局部性.</li>
</ol>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>&emsp;&emsp;早期计算机系统的存储器层次只有CPU寄存器,DRAM主存和磁盘存储.由于CPU和主存之间的差距逐渐增大,在寄存器和主存之间加入了一个SRAM高速缓存存储器.</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>时钟周期</th>
</tr>
</thead>
<tbody><tr>
<td>L1</td>
<td>2-4</td>
</tr>
<tr>
<td>L2</td>
<td>10</td>
</tr>
<tr>
<td>L3</td>
<td>30-40</td>
</tr>
</tbody></table>
<h3 id="通用高速缓存器结构"><a href="#通用高速缓存器结构" class="headerlink" title="通用高速缓存器结构"></a>通用高速缓存器结构</h3><p>&emsp;&emsp;如果每一个存储器地址有m位,形成$$M=2^{m}$$个不同的地址.一个机器的高速缓存被组织成一个有$$S=2^{s}$$个高速缓存组的数组.每一个组有E个高速缓存行(cache line).每一个行由一个$$B=2^{b}$$字节的数据库块(block)组成.一个有效位(valid bit)指明这个行是否包含有意义的信息,还有t=m-(b+s)个标记位(tag bit)唯一地标识存储在这个高速缓存行中的块.</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$$S=2^{s}$$</td>
<td>组数</td>
</tr>
<tr>
<td>$$E$$</td>
<td>每个组的行数</td>
</tr>
<tr>
<td>$$B=2^{b}$$</td>
<td>块大小(字节)</td>
</tr>
<tr>
<td>$$m=log_{2}(M)$$</td>
<td>(主存)物理地址位数</td>
</tr>
<tr>
<td>$$M=2^{m}$$</td>
<td>存储器地址的最大数量</td>
</tr>
<tr>
<td>$$s=log_{2}(S)$$</td>
<td>组索引位数量</td>
</tr>
<tr>
<td>$$b=log_{2}(B)$$</td>
<td>块偏移位数量</td>
</tr>
<tr>
<td>$$t=m-(s+b)$$</td>
<td>标记位数量</td>
</tr>
<tr>
<td>$$C=B\cdot E\cdot S$$</td>
<td>不包括有效位和标记位这样开销的高速缓存大小(字节)</td>
</tr>
</tbody></table>
<h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h3><p>&emsp;&emsp;每个组只有一行(E=1)的高速缓存称为直接映射缓存(direct-mapped cache).高速缓存确定一个请求是否命中,然后抽取出被请求的字的过程,分为1)组选择,2)行匹配,3)字抽取</p>
<ol>
<li>组选择<br>高速缓存从w的地址中间抽出s个组索引位,如果把高速缓存看成一个一维素质,这个组索引号就是这个数组的下标.</li>
<li>行匹配<br>上面的步骤选择了某个组i,下面确定字w的一个拷贝是否存储在组i包含的一个高速缓存行中.对直接映射高速缓存很容易,因为每一个组只有一个行,仅当设置了有效位,并且高速缓存行中的标记与w的地址中的标记想匹配时,这一行包含w的一个拷贝.</li>
<li>字选择<br>一旦命中,就知道w在这个块中的某个地方.如下图所示,块偏移位提供了所需要的字的第一个字节的偏移.可以把快也看成一个字节数组,字节偏移是这个数组的一个下标.</li>
</ol>
<p><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%981.jpg" alt="alter 缓存选取"><br>4. 缓存不命中时的行替换<br>如果缓存不命中,需要从下一层取出被请求的块,然后将新的块存储在组索引位指示的一个高速缓存行中.当组中都是有效高速缓存,会存在一个替换策略,驱逐一个现在的行.<br>5. 小结<br>以(S,E,B,m) = (4,1,2,4)为例<br>1.标记位和索引位决定了块号.<br>2.一共有8块,但是只有4个高速缓存组,多个块映射到同一个高速缓存组(具有相同的组索引).<br>3.映射到同一个高速缓存组的块由标记位唯一地标识.</p>
<p>ps:$$C=4 \cdot 1 \cdot 2 = 8$$, 地址数为 $$2^4=16$$,因此有一半的数据会冲突.</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>标记位</th>
<th>索引位</th>
<th>偏移位</th>
<th>块号</th>
</tr>
</thead>
<tbody><tr>
<td>(十进制)</td>
<td>(t=1)</td>
<td>(s=2)</td>
<td>(b=1)</td>
<td>(十进制)</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>00</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>00</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>01</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>01</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>10</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>11</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>11</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>1</td>
<td>00</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>01</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>01</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>12</td>
<td>1</td>
<td>10</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>13</td>
<td>1</td>
<td>10</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>11</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>15</td>
<td>1</td>
<td>11</td>
<td>1</td>
<td>7</td>
</tr>
</tbody></table>
<p>初始时,高速缓存是空的(所有的有效位为0)</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标记位</th>
<th>块[0]</th>
<th>块[1]</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>b</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<p>1)读地址0的字,因为组0的有效位为0,缓存不命中,高速缓存从低层中取出块0放入组0中.然后高速缓存返回新取的高速缓存行的块[0]的m[0].</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标记位</th>
<th>块[0]</th>
<th>块[1]</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<p>2)读地址1的字,这次高速缓存命中,返回高速缓存块[1]中的m[1]<br>3)读地址13的字,与1)一样缓存不命中.高速缓存把块6加入组2中,然后从新的高速缓存行的块[1]中返回m[13]</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标记位</th>
<th>块[0]</th>
<th>块[1]</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<p>4)读地址8的字,缓存不命中,组匹配但是标记位不匹配.高速缓存将块4加载到组0中(替换原来的块0),然后从新的高速缓存中的块[0]返回m[0].</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标记位</th>
<th>块[0]</th>
<th>块[1]</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>m[8]</td>
<td>m[9]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<p>5)读地址0的字.又会发生缓存不命中,因为在读取地址8时替换了块0.(冲突不命中)</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标记位</th>
<th>块[0]</th>
<th>块[1]</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<h3 id="直接映射的冲突不命中"><a href="#直接映射的冲突不命中" class="headerlink" title="直接映射的冲突不命中"></a>直接映射的冲突不命中</h3><p>当程序访问大小为2的幂的数组时，直接映射高速缓存中通常会发生冲突不命中，不同的数组容易映射到相同的高速缓存组。例如下面的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dotprod</span> <span class="params">(<span class="keyword">float</span> x[<span class="number">8</span>], <span class="keyword">float</span> y[<span class="number">8</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        sum += x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于x和y来说，这个函数具有良好的空间局部性，期望命中率比较高，但并不总是如此。假设浮点数为4个字节，x被加载到0开始的32字节连续存储器中，y紧跟x之后，从地址32开始。假设高速缓存大小为32字节由两个组组成，每一个块16个字节。这样的话每一个x[i]和y[i]会映射到相同的高速缓存组。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>地址</th>
<th>组索引</th>
<th>元素</th>
<th>地址</th>
<th>组索引</th>
</tr>
</thead>
<tbody><tr>
<td>X[0]</td>
<td>0</td>
<td>0</td>
<td>Y[0]</td>
<td>32</td>
<td>0</td>
</tr>
<tr>
<td>X[1]</td>
<td>4</td>
<td>0</td>
<td>Y[1]</td>
<td>36</td>
<td>0</td>
</tr>
<tr>
<td>X[2]</td>
<td>8</td>
<td>0</td>
<td>Y[2]</td>
<td>40</td>
<td>0</td>
</tr>
<tr>
<td>X[3]</td>
<td>12</td>
<td>0</td>
<td>Y[3]</td>
<td>44</td>
<td>0</td>
</tr>
<tr>
<td>X[4]</td>
<td>16</td>
<td>1</td>
<td>Y[4]</td>
<td>48</td>
<td>1</td>
</tr>
<tr>
<td>X[5]</td>
<td>20</td>
<td>1</td>
<td>Y[5]</td>
<td>52</td>
<td>1</td>
</tr>
<tr>
<td>X[6]</td>
<td>24</td>
<td>1</td>
<td>Y[6]</td>
<td>56</td>
<td>1</td>
</tr>
<tr>
<td>X[7]</td>
<td>28</td>
<td>1</td>
<td>Y[7]</td>
<td>60</td>
<td>1</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这样在访问x[0]时会把x[0]-x[3]的数据加入到组0，在访问y[0]时会导致y[0]-y[3]的块拷贝到组0，覆盖之前拷贝进来的x[0]-x[3].导致了冲突不命中。高速缓存反复地加载和驱逐相同的高速缓存块称为抖动[thrash].</p>
<p>&emsp;&emsp;因此即使程序有良好的空间局部性，高速缓存也有足够的空间来存放x[i]和y[i]的块，每次引用还是会导致冲突不命中，因为这些块被映射到同一个高速缓存组。</p>
<p>&emsp;&emsp;如果在数组后进行B字节的填充，将x定义为float x[12]就会有下面的映射关系。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>地址</th>
<th>组索引</th>
<th>元素</th>
<th>地址</th>
<th>组索引</th>
</tr>
</thead>
<tbody><tr>
<td>X[0]</td>
<td>0</td>
<td>0</td>
<td>Y[0]</td>
<td>48</td>
<td>1</td>
</tr>
<tr>
<td>X[1]</td>
<td>4</td>
<td>0</td>
<td>Y[1]</td>
<td>52</td>
<td>1</td>
</tr>
<tr>
<td>X[2]</td>
<td>8</td>
<td>0</td>
<td>Y[2]</td>
<td>56</td>
<td>1</td>
</tr>
<tr>
<td>X[3]</td>
<td>12</td>
<td>0</td>
<td>Y[3]</td>
<td>60</td>
<td>1</td>
</tr>
<tr>
<td>X[4]</td>
<td>16</td>
<td>1</td>
<td>Y[4]</td>
<td>64</td>
<td>0</td>
</tr>
<tr>
<td>X[5]</td>
<td>20</td>
<td>1</td>
<td>Y[5]</td>
<td>68</td>
<td>0</td>
</tr>
<tr>
<td>X[6]</td>
<td>24</td>
<td>1</td>
<td>Y[6]</td>
<td>72</td>
<td>0</td>
</tr>
<tr>
<td>X[7]</td>
<td>30</td>
<td>1</td>
<td>Y[7]</td>
<td>76</td>
<td>0</td>
</tr>
<tr>
<td>X[8]</td>
<td>34</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>X[9]</td>
<td>38</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>X[10]</td>
<td>42</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>X[11]</td>
<td>46</td>
<td>0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这样就消除了抖动冲突不命中。</p>
<h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h3><p>&emsp;&emsp;直接映射高速缓存冲突不命中的问题是每一个组只有一行(E=1).组相联高速缓存(set associative cache)每个组都保存多余一个的高速缓存行.</p>
<ol>
<li>组选择<br>与直接映射高速缓存的组选择一样,通过组索引位标识.</li>
<li>行匹配和字选择<br>比直接映射高速缓存的组选择复杂,因为必须检查多个行的标记位和有效位,以确定所请求的字是否在集合中.一个相联的存储器是一个(key, value)对的数组,以key为输入,返回与输入的key相匹配的(key, value)对中的value值.key是标记和有效位,value为块的内容.<br><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%982.jpg" alt="alter 缓存选取"></li>
<li>不命中时的行替换<br>当不命中时,需要从存储器中取出包含这个字的块,如果有空行就直接放入,如果没有空行则需要选择一个替换算法.</li>
</ol>
<h3 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h3><p>一个全相联高速缓存(fully associative cache)是由一个包含所有高速缓存行的组($$E=C \div B$$)组成.</p>
<ol>
<li>组选择<br>因为最有一个组,地址中不需要有索引位.地址被划分成一个标记和一个块偏移.<br><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%983.jpg" alt="alter 缓存选择"></li>
<li>行匹配和子选择<br>与组相联高速缓存一样,只是规模比组相联大.因为高速缓存电路必须并行地搜索许多相匹配的标记,构造一个又大又快的相联高速缓存很难,并且很贵.因此只适合做小的高速缓存,例如虚拟存储器系统中的翻译备用缓冲器(TLB).</li>
</ol>
<h3 id="写的问题"><a href="#写的问题" class="headerlink" title="写的问题"></a>写的问题</h3><p>写的情况比读复杂些,假如写一个已经缓存了的字w写命中(write hit).在高速缓存更新了它的w的拷贝后,怎么更新w在层次结构中紧接着低一层的拷贝呢?最简单的方法称为直写(write-through),就是立即将w写回在层次结构中紧接着的低一层中. 虽然简单但是每次都会引起总线流量.另一种方法称为写回(write-back),尽可能第推迟存储器更新.只有当替换算法需要驱逐更新过的块时才把它写到紧接着的低一层中.由于局部性,写回能显著减少总线流量,但是增加了复杂性,高速缓存必须为每个高速缓存维护一个额外的修改位(dirty bit),表示这个高速缓存块是否被修改过.</p>
<p>另一个问题是如何处理写不命中,一种方法为写分配(write-allocate),加载相应的低一层中的块到高速缓存,然后更新这个高速缓存块.试图利用写的空间局部性,但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存.另外一种为非写分配(not-write-allocate),避开高速缓存,直接把这个字写到第一层.直写高速缓存通常是非写分配的,写回高速缓存通常是写分配的.</p>
<p>对于试图编写高速缓存比较友好的程序来说,建议采用写回和写分配的高速缓存模型.通常由于较长的传送时间,存储器层次结构中较低层更可能使用写回.</p>
<h3 id="真实高速缓存层次结构"><a href="#真实高速缓存层次结构" class="headerlink" title="真实高速缓存层次结构"></a>真实高速缓存层次结构</h3><p>高速缓存既保存数据也保存指令(统一高速缓存unified cache).只保存指令的高速缓存称为i-cache.只保存程序数据的高速缓存称为d-cache.现代处理器包括独立的i-cache和d-cache.两个独立的高速缓存,处理器能够同时读一个指令字和一个数据字.i-cache通常是只读的,因此比较简单.</p>
<p>Intel Core i7 高速缓存层次结构<br><img src="/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%984.jpg" alt="alter 缓存层次结构"></p>
<table>
<thead>
<tr>
<th>高速缓存类型</th>
<th>访问时间(周期)</th>
<th>高速缓存大小(C)</th>
<th>相联度(E)</th>
<th>块大小(B)</th>
<th>组数(S)</th>
</tr>
</thead>
<tbody><tr>
<td>L1 i-cache</td>
<td>4</td>
<td>32KB</td>
<td>8</td>
<td>64B</td>
<td>64</td>
</tr>
<tr>
<td>L1 d-cache</td>
<td>4</td>
<td>32KB</td>
<td>8</td>
<td>64B</td>
<td>64</td>
</tr>
<tr>
<td>L2统一高速缓存</td>
<td>11</td>
<td>256KB</td>
<td>8</td>
<td>64B</td>
<td>512</td>
</tr>
<tr>
<td>L3统一高速缓存</td>
<td>30-40</td>
<td>8MB</td>
<td>16</td>
<td>64B</td>
<td>8192</td>
</tr>
</tbody></table>
<h3 id="高速缓存参数的性能影响"><a href="#高速缓存参数的性能影响" class="headerlink" title="高速缓存参数的性能影响"></a>高速缓存参数的性能影响</h3><ul>
<li>不命中率(miss rate):不命中数量/引用数量.</li>
<li>命中率(hit rate):命中数量/引用数量(1-不命中率).</li>
<li>命中时间(hit time):从高速缓存传送一个字到CPU所需的的时间,包括组选择,行确认,子选择时间.</li>
<li>不命中处罚(miss penalty):由于不命中所需要的额外的时间.L1不命中需要从L2得到服务的处罚,一般为10个周期;从L3得到服务的处罚一般为40个周期;从主存得到服务的处罚一般为100个周期.</li>
</ul>
<ol>
<li>高速缓存大小的影响<br>较大的高速缓存可能会提高命中率,使大存储器运行得更快比较难些.结构较大的高速缓存可能会增加命中时间.对L1的高速缓存来说命中时间必须短.</li>
<li>块大小的影响<br>较大的块能利用程序中可能存在的空间局部性,提高命中率.对于给定的大小,块越大缓存行越少,会损害时间局部性比空间局部性更好的程序中的命中率.较大的块不命中处罚也有负面影响.现代系统中高速缓存一般包含32-64个字节.</li>
<li>相联度的影响<br>E是每个组中高速缓存的行数,E较大时降低了高速缓存由于冲突不命中出现抖动的可能性.但是会造成较高的成本,且速度变慢.每一行需要更多的标记位,额外的LRU状态位和额外的控制逻辑.另外会增加命中时间(复杂了),增加命中处罚(选择牺牲行复杂了).为了折中命中时间和不命中处罚,在不命中处罚比较高的层次上使用比较大的相联度,在争取时钟频率的高性能系统会为L1使用较低的相联度.Intel Core i7中,L1和L2的E=8,L3中E=16.</li>
<li>写策略的影响<br>直写高速缓存比较容易实现,且能使用独立于高速缓存的写缓冲区(write buffer),来更新存储器.另外读不命中开销要少,因为不会触发存储器写.写回高速缓存引起的传送比较少,允许更多的到存储器的带宽用于执行DMA的I/O设备.越往层次结构下面走,传送时间增加,减少传送数量就更加重要.一般而言,高速缓存越往下层,越可能使用写回而不是直写.</li>
</ol>
<p>PS:高速缓存行,组,块的区别.</p>
<ul>
<li>块是一个固定大小的信息包,在高速缓存和主存(或下一层高速缓存)之间来回传送.</li>
<li>行是高速缓存中存储块以及其他信息(例如有效位和标记位)的容器.</li>
<li>组是一个或多个行的集合.</li>
</ul>
<p>因为一行总是存储一个块,术语行和块通常互换使用.</p>
<h2 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><p>好的程序员总是应该试着去编写高速缓存友好(cache friendly)的代码.下面是确保高速缓存友好的基本方法:</p>
<ol>
<li>让最常见的情况运行得快.程序通常把大部分时间花在少量的核心函数上,而这些函数通常吧大部分时间都花在少量循环上.因此要把注意力集中在核心函数中的循环上.</li>
<li>在每个循环内部提供循环命中率.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumvec</span><span class="params">(<span class="keyword">int</span> v[N])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    sum += v[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数高速缓存优化吗?首先局部变量i和sum循环体有良好的时间局部性,实际上优化编译器会把它们缓存在寄存器文件中.假设v是块对齐的,字为4个字节,高速缓存块为4个字.高速缓存为空,则对v的引用有下面的命中和不命中模式:</p>
<p><img src="/images/%E5%91%BD%E4%B8%AD1.jpg" alt="alter 命中"></p>
<p>这样v[0]不命中,而包含v[0]-v[3]相应的块会被从存储器加载到高速缓存中.因此接下来的三个引用都会命中.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag"># 深入理解计算机系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2015/01/10/2015-01-10-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%BC%AB%E6%B8%B8/" rel="next" title="计算机漫游">
      计算机漫游 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">1.1.</span> <span class="nav-text">存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">随机访问存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SRAM"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">SRAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DRAM"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">DRAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84DRAM"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">传统的DRAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">存储器模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84DRAM"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">增强的DRAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">非易失性存储器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">磁盘存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%9E%84%E9%80%A0"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">磁盘构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">磁盘容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">磁盘操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%A3%81%E7%9B%98%E5%9D%97"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">逻辑磁盘块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0I-O%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">连接到I&#x2F;O设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%A3%81%E7%9B%98"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">访问磁盘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="nav-number">1.1.3.</span> <span class="nav-text">固态硬盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">局部性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">对程序数据引用的局部性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">1.2.2.</span> <span class="nav-text">取指令的局部性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.3.</span> <span class="nav-text">存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.1.</span> <span class="nav-text">缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">高速缓存存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.</span> <span class="nav-text">通用高速缓存器结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">直接映射高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%9A%84%E5%86%B2%E7%AA%81%E4%B8%8D%E5%91%BD%E4%B8%AD"><span class="nav-number">1.4.3.</span> <span class="nav-text">直接映射的冲突不命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.4.4.</span> <span class="nav-text">组相联高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">1.4.5.</span> <span class="nav-text">全相联高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.6.</span> <span class="nav-text">写的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%9F%E5%AE%9E%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.7.</span> <span class="nav-text">真实高速缓存层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="nav-number">1.4.8.</span> <span class="nav-text">高速缓存参数的性能影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.</span> <span class="nav-text">编写高速缓存友好的代码</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wjainng"
      src="/images/mountain.jpg">
  <p class="site-author-name" itemprop="name">wjainng</p>
  <div class="site-description" itemprop="description">学而不思则罔思而不学则殆</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wjainng</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
