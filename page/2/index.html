<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学而不思则罔思而不学则殆">
<meta property="og:type" content="website">
<meta property="og:title" content="WJAINNG">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="WJAINNG">
<meta property="og:description" content="学而不思则罔思而不学则殆">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wjainng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WJAINNG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WJAINNG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/2020-06-14-JMM%E4%B8%8E%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/2020-06-14-JMM%E4%B8%8E%E9%94%81/" class="post-title-link" itemprop="url">JMM与锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 21:42:36" itemprop="dateCreated datePublished" datetime="2020-06-14T21:42:36+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>jdk1.5之后除了synchronized关键字还可以使用lock来进行线程的同步。Lock给使用者更多的选择，并且能支持公平和非公平的锁，获取不到锁时允许中断，超时获取锁等。<br>因为synchronized关键字是非显示的申明获取锁因此又称为隐式锁，synchronized可以用在代码块和方法上，当用在方法上时通过标记ACC_SYNCHRONIZED实现，用在代码块中通过monitorenter和monitorexit实现（javap查看）。</p>
<p>lock的使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><small>注意：<em>当使用tryLock时不能使用这种格式，会导致没有获取到锁也去释放锁，应该使用以下的方式</em></small></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Lock方法说明"><a href="#Lock方法说明" class="headerlink" title="Lock方法说明"></a>Lock方法说明</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>获取锁，获取不到则等待</td>
</tr>
<tr>
<td>void lockInterruptibly()</td>
<td>获取到锁则返回，否则加入等待队列。如果获取到锁或者被中断则返回</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>如果获取锁成功则返回true，获取失败返回false，都会立即返回不会阻塞</td>
</tr>
<tr>
<td>boolean tryLock(time, timeUnit)</td>
<td>如果获取锁成功则返回true。否则会阻塞直到获取锁或者被中断或者阻塞时间到，只有获取到锁时返回true，其他情况返回false</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>返回一个绑定到该锁的一个新的条件对象</td>
</tr>
</tbody></table>
<h4 id="同步器AQS-AbstractQueuedSynchronizer"><a href="#同步器AQS-AbstractQueuedSynchronizer" class="headerlink" title="同步器AQS(AbstractQueuedSynchronizer)"></a>同步器AQS(AbstractQueuedSynchronizer)</h4><p>同步器获取和修改状态的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getState()</td>
<td>获取当前的同步状态</td>
</tr>
<tr>
<td>setState(int newState)</td>
<td>设置当前同步状态</td>
</tr>
<tr>
<td>compareAndSetState(int expect, int update)</td>
<td>使用CAS设置同步状态</td>
</tr>
</tbody></table>
<p>同步器可以重写的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>booelan tryAcquire(int arg)</td>
<td>独占式获取同步状态,获取成功则返回true，否则返回false</td>
</tr>
<tr>
<td>tryRelease(int arg)</td>
<td>独占式释放同步状态，等待获取同步状态的线程有机会获取同步状态</td>
</tr>
<tr>
<td>boolean tryAcquireShared(int arg)</td>
<td>共享式获取同步状态，大于等于0表示获取成功，否则获取失败</td>
</tr>
<tr>
<td>tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>boolean isHeldExclusively()</td>
<td>表示当前线程是否独占锁</td>
</tr>
</tbody></table>
<p>AQS内部结构：<br><img src="/images/lock-aqs.svg"></p>
<blockquote>
<p>Conditon是锁的内部类，必须获得锁才能调用await和signal方法，condition从await返回可以当做两步理解，第一从等待队列移到同步队列，第二成为同步队列的首节点(获得锁)。</p>
</blockquote>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h5><ol>
<li>继承Thread，通过start()启动线程会执行线程的run方法。</li>
<li>实现Runnable，然后把runnable当做线程的参数，通过start()启动线程后会执行runnable的run方法[线程的默认实现run方法为调用target的run方法]。</li>
<li>针对有返回值的情况下实现Callable，然后构造一个FutureTask，把FutrueTask当做线程的参数传入线程，通过start()启动线程后最终会调用到Callable的call()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Callable callable = <span class="keyword">new</span> Callable(()-&gt;<span class="string">&quot;Say Hello&quot;</span>);</span><br><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line"><span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">futureTask.get();<span class="comment">//会返回“Say Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><small>FutureTask支持取消任务，如果任务能够响应中断还能取消正在运行的任务。submit最终也是调用execute方法，只是传递给execute的为封装为FutureTask的对象</small></p>
<p>java线程的状态及转换：<br><img src="/images/thread-status.svg"></p>
<h5 id="线程池的初始化"><a href="#线程池的初始化" class="headerlink" title="线程池的初始化"></a>线程池的初始化</h5><p>线程池初始化时可以指定核心线程数，最大线程数，线程工厂，阻塞队列，空闲时间，空闲时间参数，拒绝策略。（核心线程也可以通过设置allowCoreThreadTimeOut达到空闲时间进行移除）往线程池增加任务时的流程如下图：</p>
<p><img src="/images/thread-pool-init.svg"></p>
<p>工作线程启动后会调用runWorker方法，在循环中不断从队列中获取任务并执行任务。流程图如下：</p>
<p><img src="/images/thread-pool-run.svg"></p>
<p><small> 通过在获取task时进行工作线程的空闲时间处理，如果超过核心线程数，或者允许核心线程数移除则在获取任务时会设置最长的阻塞时间，如果这段时间还是获取不到任务则返回null，则会导致线程的runWorker方法执行完毕，最终会执行清除线程的方法。</small></p>
<blockquote>
<p>线程池执行的任务一种为runnable，一种为callable，实际是通过工作线程调用runnable和callable接口的方法。工作线程由线程池进行初始化，通过在工作线程池的run方法中执行相应的run和call方法。</p>
</blockquote>
<h5 id="线程池的停止"><a href="#线程池的停止" class="headerlink" title="线程池的停止"></a>线程池的停止</h5><p>和线程池停止相关的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>shuntDown</td>
<td>停止线程池，不再接受新的任务（放入新的任务会执行拒绝策略），已经在队列中的任务还是会执行。</td>
</tr>
<tr>
<td>shuntDownNow</td>
<td>停止线程池，不再接受新的任务（放入新的任务会执行拒绝策略），通过中断处理正在执行的任务。返回在队列中的任务列表。</td>
</tr>
<tr>
<td>awaitTermination</td>
<td>等待线程池停止，返回true表示任务都执行完成，结合shuntDown使用。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/09/2020-06-09-PPT-%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/2020-06-09-PPT-%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">PPT-专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-09 23:04:45" itemprop="dateCreated datePublished" datetime="2020-06-09T23:04:45+08:00">2020-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="审美观"><a href="#审美观" class="headerlink" title="审美观"></a>审美观</h4><p>从海报、视觉、画册、平面设计、演示中学习，增加自己的审美观。</p>
<h4 id="文字修饰"><a href="#文字修饰" class="headerlink" title="文字修饰"></a>文字修饰</h4><ol>
<li>为文字增加线框</li>
<li>倒影效果 （形状倒影）</li>
<li>镂空效果（合并形状剪除）</li>
<li>三维旋转 (颜色渐变+旋转)</li>
</ol>
<h4 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h4><ol>
<li>合并形状</li>
<li>通过形状画小图标</li>
<li>通过形状分割版面 （开放路径）</li>
<li>版面透明框</li>
<li>强度内容，增加背景形状。</li>
</ol>
<h4 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h4><ol>
<li>颜色太多</li>
<li>取色器获取配色方案</li>
<li>主色调，背景色，字体颜色</li>
<li>通过色调值变化成其他主题的颜色</li>
</ol>
<h4 id="图标优化"><a href="#图标优化" class="headerlink" title="图标优化"></a>图标优化</h4><ol>
<li>增加图标专业度</li>
<li>降低信息量</li>
<li>修饰布局</li>
</ol>
<h4 id="表格修饰"><a href="#表格修饰" class="headerlink" title="表格修饰"></a>表格修饰</h4><ol>
<li>建立主色调</li>
<li>建立边框线</li>
<li>规律性底纹</li>
</ol>
<h4 id="版面设计"><a href="#版面设计" class="headerlink" title="版面设计"></a>版面设计</h4><ol>
<li>对齐</li>
<li>对比（颜色，大小，形状，距离）</li>
<li>亲密性（相关的内容距离更近）</li>
<li>重复（风格统一）</li>
</ol>
<h4 id="页面框架"><a href="#页面框架" class="headerlink" title="页面框架"></a>页面框架</h4><ol>
<li>分割（上下，左右）</li>
<li>分裂（多个区域）</li>
<li>居中（中间放文字）</li>
<li>包围</li>
<li>对称</li>
<li>杂志</li>
</ol>
<h4 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h4><p><a target="_blank" rel="noopener" href="http://www.stickpng.org/">http://www.stickpng.org</a><br><a target="_blank" rel="noopener" href="https://huaban.com/">https://huaban.com/</a><br><a target="_blank" rel="noopener" href="http://www.yanj.cn/">http://www.yanj.cn/</a><br><a target="_blank" rel="noopener" href="https://www.zcool.com.cn/">https://www.zcool.com.cn/</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.hellofont.cn/">https://www.hellofont.cn/</a><br><a target="_blank" rel="noopener" href="https://www.iconfont.cn/">https://www.iconfont.cn/</a><br><a target="_blank" rel="noopener" href="http://font.chinaz.com/">http://font.chinaz.com/</a><br><a target="_blank" rel="noopener" href="http://www.qiuziti.com/">http://www.qiuziti.com/</a><br><a target="_blank" rel="noopener" href="https://www.58pic.com/">https://www.58pic.com/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ppj.io/">http://www.ppj.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://dribbble.com/">https://dribbble.com/</a><br><a target="_blank" rel="noopener" href="http://www.peise.net/">http://www.peise.net/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/07/2020-06-07-%E7%BA%BF%E7%A8%8B-%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/2020-06-07-%E7%BA%BF%E7%A8%8B-%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">线程-专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-07 16:03:56" itemprop="dateCreated datePublished" datetime="2020-06-07T16:03:56+08:00">2020-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程为现代操作系统的最少调度单位，也称为轻量级进程。每个线程具有自己的计数器，堆栈和局部变量，且能访问共享的内存变量。<br>java中有两种线程类型，一种普通的，一种为daemon线程，daemon线程主要用来执行一些支持性工作例如Reference Handler，Finalizer，GC线程，当jvm中只存在daemon线程时jvm会退出。<font color='red'><em>daemon线程中的finally方法有可能不会执行</em></font></p>
<ul>
<li>java线程状态流转图<br><img src="/images/thread-status.svg"></li>
</ul>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>为了避免线程的创建及销毁应该尽量使用线程池来达到同样的目的。</p>
<ul>
<li>线程池创建参数说明</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxmumPoolSize</td>
<td>最大线程数</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂</td>
</tr>
<tr>
<td>runnableTaskQueue</td>
<td>任务队列</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>空闲线程的最大存活时间</td>
</tr>
<tr>
<td>timeUnit</td>
<td>空闲线程的最大存活时间</td>
</tr>
</tbody></table>
<ul>
<li>线程池中的Work内部类说明<br>java.util.concurrent.ThreadPoolExecutor.Worker本身是一个Runnable对象，并且内部有一个thread的成员变量，同时在初始化thread时把this当做参数传入thread中，当线程启动时就会调用Worker的run方法。run方法委托给runWorker方法，在内部会循环从初始任务或者任务队列中取出任务执行对应的run方法。（被提交到线程池的任务最终都会是runnable的实现类，submit的Callable参数会被封装为FutureTask）</li>
<li>线程池中的RejectHandler内部类说明</li>
</ul>
<table>
<thead>
<tr>
<th>拒绝策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>直接抛出RejectedExecutionException</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>在调用execute方法的线程处理请求</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>丢弃被拒绝的请求本身</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃最老的未处理的请求</td>
</tr>
</tbody></table>
<ul>
<li>线程池线程创建流程图</li>
</ul>
<p><img src="/images/thread-pool.svg"></p>
<ul>
<li>线程池的种类</li>
</ul>
<ol>
<li>普通的（ThreadPoolExecutor）<br>用来执行一次性的任务。</li>
<li>定时的（ScheduledThreadPoolExecutor)<br>用来执行需要定时执行的任务，包括<em>固定频率</em>和<em>固定延迟</em>两种任务。<br>实现原理：主要通过DelayedWorkQueue和ScheduledFutureTask来实现。<br>DelayedWorkQueue：获取taks时通过比较当前时间和delay的大小进行比较，只有delay小于等于当前时间才返回task（表示已经达到task的执行时间），否则会进行等待，等待时长为delay对应的时间。当队列中有新的任务增加时会进行唤醒。（因为存在后增加的任务比先增加的任务先执行的情况）。<br>ScheduledFutureTask：在run方法执行完后会重新新增一个任务，根据固定频率和固定延迟两种方式计算下次执行的时间点。固定评率下次的执行时间为<em>任务的执行时间+period</em>，固定延迟为<em>当前时间+period</em>。（内部实现通过period&gt;0表示固定频率任务，=0表示一次性任务，&lt;0表示固定延迟任务）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/30/2020-05-30-Mybatis-%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/2020-05-30-Mybatis-%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">Mybatis-专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 16:23:44" itemprop="dateCreated datePublished" datetime="2020-05-30T16:23:44+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="xml文件解析的三种方式"><a href="#xml文件解析的三种方式" class="headerlink" title="xml文件解析的三种方式"></a>xml文件解析的三种方式</h4><h5 id="DOM方式："><a href="#DOM方式：" class="headerlink" title="DOM方式："></a>DOM方式：</h5><p>   把整个xml文件加载入内存并构建一个DOM树，基于这棵树形结构对各个节点进行操作。XML文档中的每个成分都是一个节点：有文档节点，元素节点，文本阶段，属性节点，注释节点等内容。</p>
<h5 id="SAX方式："><a href="#SAX方式：" class="headerlink" title="SAX方式："></a>SAX方式：</h5><p>   基于事件模型的方式解析XML，不需要将整个XMl文档加入内存中，只需要将一部分加载到内存即可，由SAX解析器解析到某个类型节点时，触发注册在该类型节点上的回调函数，一般通过继承DefaultHandler重写相关的回调方法即可<code>startDocument,startElement,characters,endElement,endDocument方法</code>。又称为推的模式，通过SAX解析器解析到对应的类型主动调用回调方法。（被动接受）</p>
<h5 id="StAX方式："><a href="#StAX方式：" class="headerlink" title="StAX方式："></a>StAX方式：</h5><p>   又称为拉的模式，解析器不会主动解析XMl由用户主动控制需要处理事件类型以及事件的调用。（主动接受）</p>
<h4 id="mybatis-一级缓存"><a href="#mybatis-一级缓存" class="headerlink" title="mybatis 一级缓存"></a>mybatis 一级缓存</h4><ul>
<li><p>开启或者关闭一级缓存</p>
<p>mybatis默认开启session级缓存，可以通过配置<code>&lt;settings&gt;&lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;&lt;/settings&gt;</code>关闭。（默认值为SESSION也就开启一级缓存）</p>
</li>
<li><p>缓存的cachekey</p>
<p>缓存的cachekey由<code>statementId+offset+limit+sql+params</code>组成，当这五项一样时会认为是相同的sql，可以从缓存中获取数据。</p>
</li>
<li><p>缓存失效：</p>
<p>当同一个sqlsession执行insert，update，delete，commit方法时会清除缓存。（如果获取sqlsession时指定autocomit为true则不需要手动执行commit则缓存不会清除）</p>
<blockquote>
<p>其他的sqlsession进行数据新增，修改或者删除时不会导致当前sqlsession的缓存失效，也就是一级缓存的范围是sqlsession级别，会导致因为缓存而读到之前的数据。</p>
</blockquote>
</li>
<li><p>缓存的实现：</p>
<p>mybatis的默认实现为PerpetualCache通过维护一个hashmap实现。同时还提供了很多装饰者模式实现的cache，底层用的都是PerpetualCache，只是增加了一些其他功能，例如FifoCache，LruCache，BlockingCache，SoftCache，WeakCache等。</p>
</li>
</ul>
<h4 id="mybatis-二级缓存"><a href="#mybatis-二级缓存" class="headerlink" title="mybatis 二级缓存"></a>mybatis 二级缓存</h4><ul>
<li><p>二级缓存的开启：<br>通过在mybatis-config.xml中配置<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code>开启二级缓存，同时在映射文件中配置<code>&lt;cache/&gt;</code>或者<code>&lt;cache-ref/&gt;</code>配置cache的相关内容，可以通过cache-ref配置多个MappedStatement使用同一个命名空间的cache。</p>
</li>
<li><p>二级缓存的实现：<br>mybatis开启二级缓存后则会使用CachingExecutor进行sql语句的执行，会先从二级缓存对应namespace查找对应的值(MappedStatement中配置的cache)，再从一级缓存查找，最后才会查数据库。内部都是通过PerpetualCache存储数据，数据是存在本地，并且二级缓存需要在commit之后才会生效。当有表关联的数据并且属于不同的命名空间时存在读取脏数据的情况（在命名空间A中保存了a和b表关联的结果，如果在命名空间B中更新了b表的数据在命名空间A还是获取到之前的旧内容），可以通过cache-ref使用相同的命名空间，但是会导致缓存失效的情况变多。CachingExecutor通过装饰器模式内部包装了SimpleExecutor并增加了二级缓存的内容。</p>
</li>
</ul>
<center><h6>二级缓存示意图</h6></center>

<p><img src="/images/mybatis-cache.svg"></p>
<h4 id="理解过程中梳理的图"><a href="#理解过程中梳理的图" class="headerlink" title="理解过程中梳理的图"></a>理解过程中梳理的图</h4><center><h6>SQL语句执行示意图</h6></center>

<p><img src="/images/mybatis-execute.svg"></p>
<blockquote>
<p>在上图中的核心部分，也就是Executor，StatementHandler，ParameterHandler，ResultSetHandler的处理过程中都可以编写相关的拦截器进行处理。</p>
</blockquote>
<center><h6>类之间的依赖关系（只包含主要的关系）</h6></center>

<p><img src="/images/mybatis-dependency.svg"></p>
<blockquote>
<p>ResultSetHandler中包含Executor是因为涉及到子查询和延迟加载的情况，需要重新通过Executor执行相关的命令。<br>  mybatis中的configuration是一个‘上帝类’从中可以获取Executor，StatementHandler，ParameterHandler，ResultSetHandler，并且在获取时都会调用interceptorChain.pluginAll调用拦截器进行处理。</p>
</blockquote>
<center><h6>open session对应的时序图</h6></center>

<p><img src="/images/mybatis-session.svg" alt="mybatis open session"></p>
<blockquote>
<p>configuration中存有environment对应有数据源相关的内容（对应mybatis-config.xml中配置的内容），同时有默认的executeType，通过传入从environment获取的datasource从transactionfactory获取transaction，根据transaction和executeType从configuration获取Executor，再通过Executor，configuration，autoCommit创建一个SqlSession。（Transaction的创建使用了工厂方法模式，由对应的TransactionFactory创建对应的Transaction）</p>
</blockquote>
</br>
<center><h6>执行insert时对应的时序图（以默认的实现为例）</h6></center>

<p><img src="/images/mybatis-insert.svg" alt="mybatis insert"></p>
<blockquote>
<p>对SqlSession的操作最终都会委托到Executor的update方法，Executor的update方法会清除缓存，准备好StatementHandler, StatementHandler调用ParameterHandler处理传入的参数，执行update方法，调用ResultSetHandler处理返回结果。SqlSession的commit方法通过委托给Executor最终通过Transaction执行提交。</p>
</blockquote>
<center><h6>SQL语句查询序列图</h6></center>

<p><img src="/images/mybatis-query.svg"></p>
<blockquote>
<p>上图描述的是二级和一级缓存都失败的执行情况</p>
</blockquote>
<center><h6>Mapper相关的类图</h6></center>

<p><img src="/images/mybatis-mapper-class.svg"></p>
<blockquote>
<p>MapperRegistry注册了所有Mapper类对应的MapperProxyFactory,通过MapperProxyFactory获取MapperProxy，MapperProxy为Mapper的代理类，Mapper中的Method在MapperProxy有一个对应的MapppedMethod与之相对应，通过MappedMethod的execute方法实现Mapper中Method的实际数据库的调用。MappedMethod中最终通过SqlSession进行数据库相关方法的调用。SqlCommand封装了需要执行的sql的类型以及对应的MappedStatement对应的id（类名+方法名），MethodSignature的主要作用为通过ParamNameResolver对传进来的参数进行解析。</p>
</blockquote>
<center><h6>获取mapper的时序图</h6></center>

<p><img src="/images/mybatis-mapper.svg"></p>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><ul>
<li>#{}和\${}的区别<br>#{}会生成预编译的sql，会正确处理数据类型并且可以避免sql注入，\${}仅仅是文本替换。\${}一般用在order by，group by，limit等场景。</li>
<li>like拼接%有两种方式，一种是在参数中直接拼接，另一种是通过CONCAT(‘%’,CONCAT(#{query.strategyName,jdbcType=VARCHAR},’%’))拼接。</li>
</ul>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><small>[1] Mybatis技术内幕</small></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/24/2020-05-24-Maven-%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/2020-05-24-Maven-%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">Maven-专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 19:06:50" itemprop="dateCreated datePublished" datetime="2020-05-24T19:06:50+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>maven是一个强大的构建工具，能够帮助我们进行自动化构建，从清理、编译、测试到生成报告，再到打包和部署。</p>
<h3 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h3><p>maven在安装路径的conf目录下有一个settings.xml文件，该文件可以配置全局的信息，对该电脑上的所有用户都生效。一般建议拷贝一个settings.xml文件到<del>/.m2/下只在用户范围配置信息。（</del>指用户的当前目录下）</p>
<h3 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h3><p>maven通过坐标唯一确定其依赖。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>是否必填</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>groupId</td>
<td>是</td>
<td>-</td>
<td>一般用公司域名加项目的名字</td>
</tr>
<tr>
<td>artifactId</td>
<td>是</td>
<td>-</td>
<td>项目名字加maven模块名</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>-</td>
<td>版本号</td>
</tr>
<tr>
<td>packaging</td>
<td>否</td>
<td>jar</td>
<td>打包形式</td>
</tr>
<tr>
<td>classifier</td>
<td>否</td>
<td>-</td>
<td>附属构建例如源代码，文档等需要通过插件生成</td>
</tr>
</tbody></table>
<h3 id="mavn依赖范围关系"><a href="#mavn依赖范围关系" class="headerlink" title="mavn依赖范围关系"></a>mavn依赖范围关系</h3><table>
<thead>
<tr>
<th>类型</th>
<th>编译classpath</th>
<th>测试classpath</th>
<th>运行classpath</th>
<th>样例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>spring-core</td>
<td></td>
</tr>
<tr>
<td>test</td>
<td>无效</td>
<td>有效</td>
<td>无效</td>
<td>junit</td>
<td>只有测试时需要，其他情况都不需要</td>
</tr>
<tr>
<td>runtime</td>
<td>无效</td>
<td>有效</td>
<td>有效</td>
<td>数据库驱动</td>
<td>因为测试也相当于是要运行的</td>
</tr>
<tr>
<td>provided</td>
<td>有效</td>
<td>有效</td>
<td>无效</td>
<td>servlet-api</td>
<td>容器提供，只有运行时不需要</td>
</tr>
<tr>
<td>system</td>
<td>有效</td>
<td>有效</td>
<td>无效</td>
<td>本地jar例如oracle驱动</td>
<td>与provided一样，依赖构建的环境，可能导致构建不可移植</td>
</tr>
<tr>
<td>import</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>与依赖管理一起使用</td>
</tr>
</tbody></table>
<p><font color=HotPink><em>注意：运行classpath无效时，打包时不会包含对应的jar包</em></font></p>
<p>传递性依赖和依赖范围<br>假设A依赖B，B依赖C则A对C的依赖为传递性依赖。</p>
<table>
<thead>
<tr>
<th>第一依赖/第二依赖</th>
<th>compile</th>
<th>test</th>
<th>provided</th>
<th>runtime</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compile</td>
<td>-</td>
<td>-</td>
<td>runtime</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
<td>-</td>
<td>-</td>
<td>test</td>
</tr>
<tr>
<td>provided</td>
<td>provided</td>
<td>-</td>
<td>provided</td>
<td>provided</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime</td>
<td>-</td>
<td>-</td>
<td>runtime</td>
</tr>
</tbody></table>
<blockquote>
<p>如果第二依赖为compile则传递性的依赖等同于第一依赖。当第二依赖为test时依赖不会传递。当第二依赖为provided时只有第一依赖也为provided时起作用。当第二依赖为runtime时与第一依赖一致除了compile（还是为runtime）</p>
</blockquote>
<p>可选依赖：</p>
<p>可选依赖通过&lt;option&gt;true&lt;/option&gt;实现，可选依赖不会传递，假如A依赖B，B依赖C和D并且定义为&lt;option&gt;true&lt;/option&gt;则A不会依赖C和D。如果需要使用C或者D需要在A中重新定义。例如一个持久化层包B依赖mysql或者pg的驱动包，但是实际只会使用其中的一个，则由A来确定使用哪一个。但是B在编译时必须依赖C和D。</p>
<p>依赖的排除：</p>
<p>依赖的排除&lt;exclusions&gt;&lt;execlusion&gt;&lt;groupId&gt;groupId&lt;/groupId&gt;&lt;artifactId&gt;artifactId&lt;/artifactId&gt;&lt;/execlusion&gt;&lt;/exclusions&gt;</p>
<blockquote>
<p>依赖关系优先级，路径最短的优先，非同一个文件中的优先定义的高，同一个文件中定义的则后定义的高。例如在pom文件中依赖了A和B，A和B都依赖C，则C以A中定义的优先，但是在pom文件中先后依赖了A的1.0和A的1.1版本，则以1.1版本为准。</p>
</blockquote>
<h3 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h3><p>mvn clean //清理<br>mvn compile //编译<br>mvn test //运行测试<br>mvn site //生成sit<br>mvn package //打包<br>mvn install //部署到本地仓库<br>mvn deploye //部署到远程仓库，需要配置distributionManagement<br>mvn clean install -U//-U指定强制更新，对快照版本有效<br>mvn source:jar //对源码进行打包<br>mvn help:system 打印所有java系统属性和环境变量</p>
<blockquote>
<p>mvn插件的执行格式为：mvn groupId:artifactId:version:goal（groupId和version可以省略，artifactId可以用前缀替换，例如maven官方的插件默认都是maven-***-plugin）<br>mvn执行命令时可以通过命令行传递参数例如，-Dmaven.test.skip=true调过测试代码的编译和的执行， -DskipTests只会调过测试代码的执行。</p>
</blockquote>
<h3 id="maven常用配置元素说明"><a href="#maven常用配置元素说明" class="headerlink" title="maven常用配置元素说明"></a>maven常用配置元素说明</h3><p>mirror 可以用来镜像对仓库的引用，例如配置一个阿里的镜像来加快依赖包的下载。<br>repository 用来定义不同的仓库，可以设置是否允许快照版本，以及更新频率，快照默认为1天更新一次。可以通增加-U强制刷新,例如mvn clean install -U。<br>servers 用来配置用户名和密码，配置代理，访问远程仓库，上传jar包到私服时可能需要登录信息。<br>proxy 用来设置代理，例如有些公司外网需要通过代理进行访问。<br>dependency 用来配置依赖。<br>dependencyManagement 用来配置依赖管理，主要是管理版本信息。<br>distributionManagement 用来配置上传jar包对应的repository。可以通过在pom或者setting.xml中的profile中定义。</p>
<pre><code>用于部署本地jar包到私服，一般需要同时在server下配置id对应的用户名密码。distributionManagement可以在pom文件中定义，和profile中定义
&lt;distributionManagement&gt;
  &lt;repository&gt;
    &lt;id&gt;release&lt;/id&gt;
  &lt;name&gt;release repository&lt;name&gt;
  &lt;url&gt;ip:port/nexus/content/repositories/releases&lt;/url&gt;
  &lt;/repository&gt;
  &lt;repository&gt;
    &lt;id&gt;snapshorts&lt;/id&gt;
    &lt;name&gt;snapshorts repository&lt;name&gt;
    &lt;url&gt;ip:port/nexus/content/repositories/snapshorts&lt;/url&gt;
  &lt;/repository&gt;
&lt;/distributionManagement&gt;
servers只能在setting.xml文件中配置
&lt;servers&gt;
  &lt;server&gt;
    &lt;id&gt;releases&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;*****&lt;/password&gt;
  &lt;/server&gt;
&lt;/servers&gt;</code></pre>
<h3 id="生命周期和绑定"><a href="#生命周期和绑定" class="headerlink" title="生命周期和绑定"></a>生命周期和绑定</h3><p>maven一共有三个生命周期，每个生命周期又包括不同的阶段，通过将插件绑定到不同生命周期的不同阶段实现不同的目标，同一个生命周期的同一个阶段如果有多个插件绑定则执行顺序由声明的顺序决定。</p>
<ol>
<li>clean生命周期</li>
<li>default生命周期</li>
<li>sit生命周期</li>
</ol>
<p>生命周期之间没有先后顺序，同一个生命周期的不同阶段是有先后顺序的，执行后面的阶段会导致之前的阶段都会执行。（生命周期的阶段类似于模板方法）</p>
<h3 id="maven插件"><a href="#maven插件" class="headerlink" title="maven插件"></a>maven插件</h3><h4 id="插件的解析"><a href="#插件的解析" class="headerlink" title="插件的解析"></a>插件的解析</h4><p>官方插件的默认groupId为org.apache.maven.plugins可以省略，同时前缀和artifactId可以通过settings.xml文件配置自定义的内容，这样可以通过前缀匹配到artifactId，版本号通过最新的或者超级POM中配置的版本号获取。</p>
<p>org/apache/maven/plugins/artifactId/maven-metadata.xml定义了插件的版本信息<br>org/apache/maven/plugins/maven-metadata.xml中检查前缀对应的artifactId。<br> <pluginGroups><br>  <pluginGroup>com.your.plugins</pluginGroup><br> </pluginGroups><br>还会检查com/your/plugins/maven-metadata.xml中的内容</p>
<blockquote>
<p>mvn dependency:tree 可以打印依赖树，mvn dependency:analyze可以对依赖包进行分析，会输出哪些有引用但是没有依赖的以及依赖但是没有使用的包。ide中可以通过show effective pom生成最终生效的pom文件，和查看包的依赖关系图。</p>
</blockquote>
<h4 id="插件的实现"><a href="#插件的实现" class="headerlink" title="插件的实现"></a>插件的实现</h4><p>通过继承org.apache.maven.plugin.AbstractMojo实现，同时插件对应的打包方式必须为maven-plugin，插件需要指定goal和绑定阶段。</p>
<h3 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h3><p>聚合：当需要把多个模块聚合在一起时使用。<br>继承：子模块会继承父模块的属性，例如依赖，groupId，artifactId等。</p>
<p>聚合和继承POM中的packaging必须是pom，一般项目的根同时是聚合POM和父POM。</p>
<blockquote>
<p>dependencyManagement声明依赖但是不会引入依赖，一般用来定义版本号，用来保证同一个项目中的不同模块都使用同一个版本的jar包。dependencyManagement中可以声明import的scope用来引用其他文件的dependencyManagement声明的内容。</p>
</blockquote>
<h3 id="maven内置变量及profile"><a href="#maven内置变量及profile" class="headerlink" title="maven内置变量及profile"></a>maven内置变量及profile</h3><p>内置属性：${basedir}, ${version}<br>POM属性：${project.artifactId}, ${project.build.sourceDirectory}等<br>自定义属性：在POM中定义的properties属性。<br>Settings属性：${settings.localRepository}<br>Java系统属性：${user.home}可以通过mvn help:system查看<br>环境变量属性：${env.JAVA_HOME}</p>
<h3 id="nexus-说明"><a href="#nexus-说明" class="headerlink" title="nexus 说明"></a>nexus 说明</h3><p>maven中分本地仓库和远程仓库，远程仓库再分中央仓库，私服，其他远程仓库。默认先从本地仓库找，只有在本地仓库找不到才从远程仓库找。</p>
<p>nexus中内置的仓库</p>
<ol>
<li>Maven Central：代理Maven的中央仓库，只会下载和缓存中央仓库的release版本。</li>
<li>Releases：release版本的宿主类型仓库，用来部署组织内的发布版本。</li>
<li>Snapshots：snapshot的宿主类型仓库，用来部署组织内的快照版本。</li>
<li>3rd party：release版本的宿主类型仓库，用来部署无法从公共仓库获得的第三方发布版本。</li>
<li>Public Repositories：将所有的release仓库聚合并通过一致的地址提供服务。</li>
<li>Public Snapshot Repositories：将所有的snapshot仓库聚合并通过一致的地址提供服务。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/21/2020-05-21-GIT-%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/2020-05-21-GIT-%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">GIT-专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-21 23:27:07" itemprop="dateCreated datePublished" datetime="2020-05-21T23:27:07+08:00">2020-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Git是一个开源的分布式版本控制系统。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><pre><code>git init &lt;directory&gt; 当前目录初始化git本地仓库
git clone &lt;remote_url&gt; 基于远程仓库克隆至本地

git add -A|&lt;fileName&gt;|&lt;directory&gt; 增加所有/文件/目录到暂存区

git rm --cached target -r 将指定的target移除暂存区

git commit -am remark 将所有文件提交，remark为描述
git commit file -m remark 将file提交，remark为描述

git reset --mixed|soft|hard HEAD~[1,2,3] 撤回commit到前一个，前2个提交.
git checkout -- filename 会撤销对filename的修改，直接用最新的版本替换
git commit --amend 只想更改注释时使用

git branch -avv 查看当前分支
git branch &lt;branch name&gt; 基于当前分支创建新的分支
git branch &lt;branch name&gt; &lt;commit id&gt; 基于提交创建分支
git branch -d &lt;branch name&gt; 删除分支
git branch &lt;new branch name&gt; &lt;base branch name&gt; 基于base创建new
git checkout &lt;branch name&gt; 切换到branch name
git checkout -b bf origin/serverfix 基于远程serverfix创建bf分支并切换到bf分支
git checkout --track origin/serverfix 类似上面的命令只是新建的分支也是serverfix
git merge &lt;target&gt; 将target分支合并到当前分支

git remote -v 查看远程分支
git remote add origin &lt;remote url&gt; 增加远程地址
git remote remove origin 删除远程地址
git push -u origin master 上传分支到远程(--set-upstream-to)第一次需要使用这种方式
git push -u origin localbranch:remobebranch 当本地和远程的分支名不一样时使用local:remote的形式 
git push origin/master:
git branch -u origin/master master 把本地分支master关联到远程分支origin/master
git push origin --delete branch 删除远程branch分支

git pull 想当于git fetch + git merge 从远程拉取数据并合并到当前分支

git tag 查看tag
git tag tagName 根据当前分支创建tag
git tag tagName branchName 根据branchName创建tagName
git tag -d tagName 删除tagName

git log 查看当前分支log
git log branchName 查看branchName分支log
git log --oneline 单行显示日志
git log branch1..branch2 比较两个分支的差异(显示branch2比branch1多的内容)
git diff branch1 branch2 fileName 比较两个分支对应fileName的差异
git log --pretty=format:&#39;%h %s&#39; --graph 以图表形式显示提交网络

git stash 会储藏工作目录的脏的状态，然后工作区会回到之前的状态，可以进行分支切换。（后续可以重新应用这些改动）
git stash list 可以查看所有的暂存信息
git stash apply [stashname] 可以重新应用暂存的内容
git stash drop [stashname] 删除暂存内容
git stash pop 应用暂存内容然后从栈上扔掉它

git --help 查看git的命令详情
git help commit 查看commit命令的详情(git commit --help, man git-commit)这三个命令是一样的效果
git config --list 查看配置信息</code></pre>
<blockquote>
<p>说明：git reset 默认为mixed：<strong>不删除</strong>工作空间改动代码，<strong>撤销</strong>commit和add操作。soft：<strong>不删除</strong>工作空间改动代码，<strong>撤销</strong>commit，<strong>不撤销</strong>add操作。hard：<strong>删除</strong>工作空间改动代码，<strong>撤销</strong>commit和add操作。<br><br>大部分命令默认是第二个参数是当前分支，除非指定第二个参数。<br><br>git init –bare 用来创建裸仓库，会直接把.git目录下的内容显示出来（裸仓库不包含工作区因此不能执行git相关的命令）一般远程仓库建议用裸仓库，这样就不能在远程直接修改文件了，减少冲突的几率。</p>
</blockquote>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ol>
<li><p>GIT提交对象</p>
<p>每一次提交为当前版本的一个快照，存储的内容为：一个顶级的树对象，上一次提交的对象hash，提交者的用户名，邮箱，提交时间以及评论。</p>
</li>
<li><p>GIT树对象</p>
<p>包含多个文件名称与其对应的hash，以及其他树对象的引用。类似于文件系统的文件夹。</p>
</li>
<li><p>GIT存储对象</p>
<p>存储实际的文件内容</p>
</li>
<li><p>GIT引用</p>
<p>当执行git branch branchName创建分支时，就是基于当前分支最新的提交创建一个应用文件，保存在.git/refs/heads下(存在分支引用，远程分支引用，标签引用三种类型)</p>
</li>
</ol>
<p><img src="/images/git_three_tree.svg" alt="git中的三棵树"></p>
<p>通过这三颗树可以很好的理解reset和checkout命令的影响</p>
<table>
<thead>
<tr>
<th>&nbsp;</th>
<th>HEAD</th>
<th>索引</th>
<th>工作区间</th>
<th>工作区间是否安全</th>
</tr>
</thead>
<tbody><tr>
<td>commit级别</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset –soft [commit]</td>
<td>REF</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>reset [commit]</td>
<td>REF</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>reset –hard [commit]</td>
<td>REF</td>
<td>是</td>
<td>是</td>
<td><font color=red><strong>否</strong></font></td>
</tr>
<tr>
<td>checkout [commit]</td>
<td>HEAD</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>文件级别</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset (commit) [file]</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>checkout (commit) [file]</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td><font color=red><strong>否</strong></font></td>
</tr>
</tbody></table>
<p><em>reset和checkout的区别之一是reset会更改分支的指向，而checkout只会更改head的指向</em></p>
<blockquote>
<p>git cat-file -p hash 可以查看对应hash文件中的内容。<br>git hash-object -w fileName 相当于git add fileName把文件写入。<br>每次修改文件后提交，至少会新增一个commit对象，一个树对象，一个文件对象。<br>(find .git/objects -type f 查看所有的文件)<br>git ls-tree -r HEAD 查看最新版本的内容<br>git ls-files -s 查看add但是没有commit的内容</p>
</blockquote>
<h2 id="GIT支持的协议"><a href="#GIT支持的协议" class="headerlink" title="GIT支持的协议"></a>GIT支持的协议</h2><ol>
<li><p>Local（本地协议）</p>
<p>基于文件系统共享，只能在局域网使用，速度慢。使用文件系统对应的权限。</p>
</li>
<li><p>ssh</p>
<p>搭建简单，通过ssh访问是安全的，权限体系不灵活，必须提供操作系统账号密码，无法创建只读权限。</p>
</li>
<li><p>http</p>
<p>依赖于web容器，搭建复杂一些。又分为智能http和哑http协议（其中哑协议是只读的，相对于提供一个静态文件服务）。</p>
</li>
<li><p>git</p>
<p>无授权机制，需要开启一个新的守护进程，传输速度最快。</p>
</li>
</ol>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>下图是一个典型的分支管理方式，master保存最新的代码，功能在feture分支开发，开发完后提交到master，有master创建release分支进行集成测试及发布，最终合并到master和打发布的标签。<br><img src="/images/git-branch.svg" alt="git 分支管理"></p>
<p>git merge source（合并source到当前分支）为了提交树更容易看懂，可以通过rebase进行合并，前提是source分支没有提交到远程，否则会引发其他麻烦。</p>
<p>git rebase master （当前分支dev基于master分支进行rebase）<br>git checkout master 切换到master分支<br>git merge dev 合并dev到master分支，会进行fast forward，提交树会变成一条直线。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/22/2019-12-22-Spring-MVC-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/22/2019-12-22-Spring-MVC-%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Spring MVC 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-22 16:00:32" itemprop="dateCreated datePublished" datetime="2019-12-22T16:00:32+08:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DispatcherServlet</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/15/2019-12-15-Spring%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/15/2019-12-15-Spring%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">Spring笔记汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-15 22:15:44" itemprop="dateCreated datePublished" datetime="2019-12-15T22:15:44+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-bean生命周期"><a href="#Spring-bean生命周期" class="headerlink" title="Spring bean生命周期"></a>Spring bean生命周期</h1><p>在Spring容器中bean是通过BeanDefinition表示的.其中描述了bean定义的各种属性,例如是不是抽象的,是否具有factory-method等.</p>
<h3 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h3><ol>
<li><p>通过构造函数创建实例,例如通过xml文件中配置<code>&lt;bean id=&quot;clientService&quot; class=&quot;example.ClientService/&gt;.</code></p>
</li>
<li><p>通过静态工厂方法创建实例,例如通过xml中的<code>&lt;bean id=&quot;clientService&quot; factory-method=&#39;createInstance&#39; class=&quot;example.ClientService&quot;/&gt;</code>则通过example.ClientService.createInstance静态方法创建example.ClientService.</p>
</li>
<li><p>通过实例的工厂方法创建实例,<code>&lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createInstance&quot;&gt;</code>其中serviceLocator为定义的另外一个bean的名字,通过serviceLocator.createInstance方法创建clientService实例.</p>
</li>
</ol>
<h3 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h3><ol>
<li>构造函数注入。</li>
<li>setter注入。</li>
<li>方法注入。<br> 3.1 lookup method injection。<br> <code>&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</code>被注入的方法必须满足上面的声明格式。(相当于一个模板方法)<br> 3.2 method replacement。<br> 通过实现MethodReplacer接口，提供一个新的方法替换原来的方法。</li>
</ol>
<blockquote>
<p>方法注入是通过代理实现，优先考虑构造函数注入，可以保证对象实例化后其属性是已经赋值了的。</p>
</blockquote>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>single：默认是single类型，容器中只有一个实例，并且由容器管理生命周期。<br>prototype：每次从容器中获取时都会实例化一个新的对象。<br><em>request,session,application,websocket</em>：需要在web环境下才能使用。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>prototype的对象，其初始化回调方法会执行，但是对应的销毁回调方法不会执行，因此对一个作用域为prototype的对象，定义销毁方法没意义。</li>
<li>如果需要把作用域为prototype的对象注入到作用域为single的对象，需要使用lookup method injection。或者<code>@Scope(value=&quot;prototype&quot;,proxyMode=ScopedProxyMode.TARGET_CLASS)或者增加&lt;aop:scoped-proxy/&gt;&lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;&gt;&lt;aop:scoped-proxy/&gt;&lt;/bean&gt;</code></li>
</ol>
</blockquote>
<h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><ul>
<li>初始化回调方法<ul>
<li>@PostConstructor。（通过BeanPostProcessor实现）</li>
<li>实现InitializingBean。（afterPropertiesSet方法）</li>
<li>手工配置init method或者default init method。</li>
</ul>
</li>
<li>销毁回调方法<ul>
<li>@PreDestroy。（通过BeanPostProcessor实现）</li>
<li>实现DisposableBean。（destroy方法）</li>
<li>手工配置destroy method或者default destroy method。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果同一个方法多次配置也只会执行一次，另外需要注意作用域为prototype的实例，对应的销毁回调方法不会执行。（<em>AOP的实现是通过BeanPostProcessor的postProcessAfterInitailization实现，因此回调方法不会被拦截</em>）</p>
</blockquote>
<ul>
<li><p>启动和关闭回调方法（容器收到启动或者关闭方法时执行）<br>由实现LifecycleProcessor的类具体实现（DefaultLifecycleProcessor）。</p>
</li>
<li><p>容器关闭的回调方法<br>通过ctx.registerShutdownHook()实现。</p>
</li>
</ul>
<h3 id="Spring容器的扩展点"><a href="#Spring容器的扩展点" class="headerlink" title="Spring容器的扩展点"></a>Spring容器的扩展点</h3><ul>
<li>通过BeanPostProcessor自定义bean.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">该接口中的方法在bean实例化之后执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    该方法在bean的任何初始化方法之前执行,例如InitializingBean的afterPropertiesSet,自定义的init-method,但是在其bean对应的属性已经赋值之后(例如setter注入的属性)</span></span><br><span class="line"><span class="comment">    可以返回目标实例的包装实例.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    该方法在初始化方法执行后执行,例如InitializingBean的afterPropertiesSet和自定义的init-method后</span></span><br><span class="line"><span class="comment">    该方法在postProcessBeforeInstantiation方法返回了值的时候也会执行(触发了短路),但是postProcessBeforeInitialization不会执行.</span></span><br><span class="line"><span class="comment">    可以返回目标实例的包装实例.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    该方法在对象实例化之前调用,这个时候目标对象还未实例化,可以通过这个返回值来代替原本该生成的目标对象的实例.如果返回了不为null的对象,则后续只有postProcessAfterInitialization方法会调用.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    该方法在目标对象实例化后调用,但是该实例的属性没有设置,该方法的返回值决定要不要调用postProcessPropertyValues方法.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    该方法可以对属性值进行修改或者验证是否必填的属性是否有值.(该方法在属性注入之前调用)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    		PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上两个接口分别代表了bean的初始化和实例化两个阶段可以进行扩展的地方。（只会对本容器的bean产生作用，并且对本身不会起作用）</p>
</blockquote>
<ul>
<li>通过BeanFactoryPostProcessor自定义bean的元数据,即通过修改BeanDefinition的内容进行bean的自定义.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过FactoryBean自定义初始化逻辑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过FactoryBean可以自定义bean的生成.</li>
</ul>
<h3 id="注解相关的配置"><a href="#注解相关的配置" class="headerlink" title="注解相关的配置"></a>注解相关的配置</h3><blockquote>
<p>@Autowired,@Inject,@Value,@Resource注解都是通过BeanPostProcessor实现的，因此不能在BeanPostProcessor和BeanFactoryPostProcessor中通过这些注解进行注入，必须通过XML文件或者@Bean进行注入。</p>
</blockquote>
<p>可以通过@Primary设置根据type注入时的优先级。还可以通过@Qualifier指定对应的名字。</p>
<p>@Autowired默认使用byType注入，当找到多个时使用byName注入，默认是required。@Resource默认使用byName注入，后使用byType注入。</p>
<p>自动注入的方式：none,byName,byType,constructor,autodetect(先构造函数再byType)</p>
<h3 id="BeanNameAutoProxyCreator详解"><a href="#BeanNameAutoProxyCreator详解" class="headerlink" title="BeanNameAutoProxyCreator详解"></a>BeanNameAutoProxyCreator详解</h3><p>通过beanNames属性指定需要代理的bean的名字,通过interceptorNames指定代理对应的intercepts.主要方法的实现在AbstractAutoProxyCreator类中.</p>
<ul>
<li><p>postProcessBeforeInstantiation通过判断是否具有自定义的TargetSource如果有则通过为自定义的targetSource创建一个代理,并返回.(BeanPostProcessor的初始化相关的方法不会执行,只会执行postProcessBeforeInitialization方法)</p>
</li>
<li><p>postProcessAfterInitialization中通过warpIfNecessary进行代理类的创建.通过获取与该bean相关的advice和advisor,通过ProxyFactory最终创建对应的代理类.</p>
<blockquote>
<p>wrapIfNecessary中通过getAdvicesAndAdvisorsForBean的反回值判断是否需要创建代理类,该方法返回匹配对应bean的advice和advisor.</p>
</blockquote>
</li>
</ul>
<h3 id="annotation-driven详解"><a href="#annotation-driven详解" class="headerlink" title="annotation-driven详解"></a>annotation-driven详解</h3><p>由TxNamespaceHandler中init方法的<code>registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser());</code>可知,主要由AnnotationDrivenBeanDefinitionParser进行注解的解释.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">	String mode = element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">		<span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">		registerTransactionAspect(element, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// mode=&quot;proxy&quot;</span></span><br><span class="line">		AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的方法可知,根据mode的不同是通过aspectj还是proxy实现AOP.以proxy的方式为例:</p>
<ul>
<li>注册一个InfrastructureAdvisorAutoProxyCreator.</li>
<li>创建TransactionAttributeSource定义.(AnnotationTransactionAttributeSource通过注解判断是否满足要求)</li>
<li>创建TransactionInterceptor定义.</li>
<li>创建TransactionAttributeSourceAdvisor定义.</li>
</ul>
<h3 id="Spring事物管理"><a href="#Spring事物管理" class="headerlink" title="Spring事物管理"></a>Spring事物管理</h3><p>从上面的内容可知声明式事物的时候会创建TransactionInterceptor,其实是一个是surround advice.可以在方法执行前后进行处理,例如开始事物,方法执行后,根据方法执行的情况进行事物的提交或者回滚.具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">    <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">    TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">    Object retVal = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">    	<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">    	retVal = invocation.proceedWithInvocation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    	<span class="comment">// target invocation exception</span></span><br><span class="line">    	completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    	<span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    	cleanupTransactionInfo(txInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    commitTransactionAfterReturning(txInfo);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ThrowableHolder throwableHolder = <span class="keyword">new</span> ThrowableHolder();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">    	TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> invocation.proceedWithInvocation();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">            	<span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">            	<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            		<span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">else</span> &#123;</span><br><span class="line">            		<span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">            	throwableHolder.throwable = ex;</span><br><span class="line">            	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">finally</span> &#123;</span><br><span class="line">    		cleanupTransactionInfo(txInfo);</span><br><span class="line">    	&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line">    	<span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> ex.getCause();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">    		ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">throw</span> ex2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">throw</span> ex2;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事物相关对象说明:</p>
<ul>
<li><p>TransactionInfo:用来保存事物相关的信息.例如事物管理器,事物的状态,切入点,事物属性等.</p>
</li>
<li><p>TransactionAttribute:继承TransactionDefinition定义了事物的一些属性,例如传播方式,超时时间,隔离级别等.</p>
</li>
<li><p>TransactionManager:定义了事物处理的方法,通过TransactionDefinition获取TransactionStatus.提交或者回滚TransactionStatus代表的事物.</p>
</li>
<li><p>TransactionStatus:表示事物的状态,例如是否为新的事物,是否有savepoint,是否rollbackOnly,是否完成等.(只有是新事物才会真正的提交,与事物的传播机制有关)</p>
</li>
</ul>
<blockquote>
<p>关于事物管理器的说明：&lt;tx:annotation-driven transaction-manager=”transactionManager”&gt;&lt;/tx:annotation-driven&gt;中的transaction-manager为默认的事物管理器，不指定时其名字默认为”transactionManager”，也可以通过@Transaction(“txMg”)指定事务管理器，如果没有指定则会使用tx:annotation-driven中指定的事物管理器。</p>
</blockquote>
</br>

<blockquote>
<p><strong>注意：</strong>如果方法a定义为需要事物，方法b定义为需要新开启一个事物，如果在方法a中直接调用方法b不会生效，因为在方法a中调用b的对象是真实的对象而不是代理的对象，如果要生效需要把bean配置的expose-proxy属性设置为true，同时通过AopContext.currentProxy()调用b方法。</p>
</blockquote>
<p>事务的传播方式：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>需要事务，如果没有则新建一个事务</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果之前有事务则在事务中，否则无事务</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>需要在事务中执行，如果之前没有事务则抛出异常</td>
</tr>
<tr>
<td>REQUIRED_NEW</td>
<td>需要开启一个新的事务，如果之前有事务则把之前的事务挂起</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不支持事务，如果之前有事务则把之前的事务挂起</td>
</tr>
<tr>
<td>NEVER</td>
<td>不支持事务，如果有事务抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果有事务则作为嵌套事务运行，否则和REQUIRED一样</td>
</tr>
</tbody></table>
<blockquote>
<p>NESTED方式时如果外部事务回滚则NESTED中的内容也会回滚，但是REQUIRED_NEW时不会回滚。</p>
</blockquote>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>@EnableAspectJAutoProxy后可以通过@Aspect进行AOP的设置。</p>
<ol>
<li>@Around 可以修改返回值，控制目标方法是否执行。</li>
<li>@Before 不可以阻止目标方法的执行，除非抛出异常。</li>
<li>@After </li>
<li>@AfterReturning 正常返回时执行与AfterThrowing二选一，可以获得返回值。</li>
<li>@AfterThrowing 抛出异常时执行。</li>
</ol>
<blockquote>
<p>当有多个Advice时通过设置@Order或者实现Order接口确定优先级，值越少优先级越高。优先级高时（Around的前处理）Before会先执行，相反优先级低的（Around的后处理），After，AfterReturning，AfterThrowing会先执行。</p>
</blockquote>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ContextRefreshedEvent</td>
<td>refresh方法调用时推送，bean被加载了，前后置处理器已经加载，单例已经实例化，ApplicationContext可以被使用</td>
</tr>
<tr>
<td>ContextStartedEvent</td>
<td>start方法调用时推送，Lifecycle对象会收到start的消息</td>
</tr>
<tr>
<td>ContextStoppedEvent</td>
<td>stop方法调用时推送，Lifecycle对象会收到start的消息</td>
</tr>
<tr>
<td>ContextClosedEvent</td>
<td>close方法调用时推送，此时单例将会被销毁（或许通过jvm的shutdown hook调用）</td>
</tr>
<tr>
<td>RequestHandledEvent</td>
<td>MVC中一个请求被处理完时推送</td>
</tr>
<tr>
<td>ServletRequestHandledEvent</td>
<td>是RequestHandledEvent的一个子类，增加了Servlet相关信息。</td>
</tr>
</tbody></table>
<blockquote>
<p>默认事件是同步执行的，可以通过设置处理器，或者把方法标志位@Async在单独的线程中处理。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/11/09/2019-11-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/2019-11-09-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">数据库汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-09 19:54:08" itemprop="dateCreated datePublished" datetime="2019-11-09T19:54:08+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>针对最近看的资料和个人理解，把相关的知识整理如下。</p>
<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>表中的列具有原子性，不能再进行拆分。例如通讯录表如果一个人既有公司电话又有家庭电话应该定义两个字段进行区分，而不是定义一个字段。</p>
<table><tr><td>姓名</td><td>*家庭号码*</td><td>*公司电话号码*</td></tr></table>


<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><ul>
<li>必须满足第一范式。</li>
<li>每一个表必须有一个主键。</li>
<li>非主键字段必须全部依赖主键，不能只部分依赖主键。<br>假如有以下的订单详情信息：</li>
</ul>
<table><tr><td>订单ID</td><td>商品ID</td><td>商品名称</td><td>购买数量</td></tr></table>

<p>显然订单<strong>ID+商品ID</strong>为主键，其中购买数量字段依赖于主键，但是商品名称字段只依赖于商品ID字段，因此不满足第二范式。</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><ul>
<li>必须满足第二范式。</li>
<li>不存在传递依赖，也就是不存在非主字段A依赖于非主字段B，非主字段B依赖于主键字段。</li>
</ul>
<p>假如有以下的订单汇总信息：</p>
<table><tr><td>订单ID</td><td>订单总金额</td><td>用户ID</td><td>用户名称</td></tr></table>

<p>显然<strong>订单ID</strong>可以作为主键，表示一个订单的汇总信息，用户ID依赖于订单ID，用户名称依赖于用户名称，不满足第三范式。（把用户名称从表中移除就满足要求）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了以上三种范式，还有BCNF范式，第四范式，第五范式。越往后数据库的冗余越小。冗余越少越容易进行更新，并且保证数据的一致性。冗余越多越方便查询，不需要进行表的关联，实际应用中应该根据实际情况进行处理，如果一个字段的更新场景不多，适当的冗余也是可以的，尤其是不允许更新但是查询多的字段。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li><p>A: 原子性，事务中的操作相当于一个原子操作要么全部成功要么全部回滚，不存在一部分操作成功的情况。（mysql中通过redo日志保证）。</p>
</li>
<li><p>C：一致性，事务把数据库从一个一致的情况转移到另外一个一致的情况，事务前后数据库属于一致的情况，例如不会因为事务导致数据库的唯一约束被打破。</p>
</li>
<li><p>I：隔离性，多个事务之间的操作不相互影响，一个事物的操作对另一个事物不可见。（与具体的隔离级别有关系）。</p>
</li>
<li><p>D：持久性，事物一旦提交即是持久的，不会因为数据库的宕机而导致数据丢失。（如果是对应的磁盘有问题，还是会导致数据丢失，属于高可用的范畴）</p>
</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li><p>读未提交：事务2可以读到事务1没有提交的数据，也就是会出现脏读现象。一般不会设置为该级别。</p>
</li>
<li><p>读可提交：事务2可以读到事务1已经提交的数据，但是会出现事务2的同一个语句在事务1提交前后的结果不一致，出现不可重复读的现象[会出现同一条数据前后两次获取的内容不一致]。（oracle的默认级别）</p>
</li>
<li><p>可重复读：事物2的同一个语句在事物的整个过程中读到的内容是一致的，但是会出现幻读的情况[主要是针对数据有新增或删除的情况，记录的条数有变化]。（mysql默认级别）</p>
</li>
<li><p>串行化：事务只能串行执行，一次只允许一个事务。</p>
</li>
</ul>
<p><sub>mysql默认为RR的原因是避免在statement复制时的不一致性。（binlog中是按事物提交时间记录日志，如果第二个事务修改的数据导致第一个事务更新的数据发生变化就会有问题）。<em>mysql的可重复读，通过间隙锁不会出现幻读的情况，具体见后续的内容</em></sub></p>
<h2 id="mysql数据库相关内容"><a href="#mysql数据库相关内容" class="headerlink" title="mysql数据库相关内容"></a>mysql数据库相关内容</h2><p>以下内容是针对mysql数据库的一些笔记，主要是涉及到innodb引擎。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>mysql的innodb引擎中表是索引组织表。（聚簇索引）</p>
<ul>
<li><p>主键索引中，非叶子节点存放的是主键的信息，叶子节点存的是对应的数据信息。（如果没有主键，则默认使用第一个定义的非空的唯一索引，如果不满足条件则会数据库内部生成一个字段当做索引）</p>
</li>
<li><p>辅助索引中，非叶子节点存放的是索引的信息，叶子节点存放对应索引的主键值。<br>（组合索引中非叶子节点存放的是组合索引对应的多个字段的信息）</p>
</li>
</ul>
<p><sub>1. 索引一般是3层左右，通过主键查询数据时最多需要3次磁盘IO，如果是通过辅助索引则需要6次磁盘IO，先通过辅助索引找到对应的主键，再通过主键查询获取数据。（IOPS按60算，通过主键查找大概需要50ms，辅助索引则需要100ms)</sub></p>
<p><sub>2. innodb中默认一个页是16K，如果一条数据为1k则叶子节点的一页可以存16条数据，如果主键为long类型占8字节，加上一个6字节的指针，则一个非叶子节点可以存16K/14=1170个主键和对应的指针，则一个2层的索引可以存1170*16=18720条数据。一个三层的索引可以存2000万的数据。</sub></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>按锁定的对象可以分为表锁和行锁。<br>其中表锁有:IS,IX,S,X,AI锁。<br>行锁有:S,X。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁的类型如下：</p>
<ul>
<li><p>IS（LOCK_IS）：为意向共享锁，事务在获得记录的S锁时，必须在表上获取IS锁或者在表上加比IS锁更强的锁。</p>
</li>
<li><p>IX(LOCK_IX)：为意向排他锁，事务在获得记录的X锁时，必须在表上获得IX锁或者在表上加比IX锁更强的锁。</p>
</li>
<li><p>S(LOCK_S)：表共享锁。</p>
<ol>
<li>当会话为非自动提交时，执行<strong>lock table <em>tablename</em> read</strong>时加共享锁。</li>
<li>在DDL的第一个阶段，如果DDL不能在线执行，则对表加共享锁。</li>
</ol>
</li>
<li><p>X(LOCK_X)：表排它锁。</p>
<ol>
<li>当会话为非自动提交时，执行<strong>lock table <em>tablename</em> write</strong>时加排它锁。</li>
<li>在DDL的最后一个阶段，对表加排它锁，确保没有别的事物持有表级锁。</li>
<li>对某个表空间执行discard或者import操作时加排它锁。</li>
</ol>
</li>
<li><p>AI(LOCK_AUTO_INC)：自增长锁，锁的范围为SQL级别，SQL结束后即释放。(违反2PC原则),自增锁有以下三种模式。</p>
<ol>
<li>AUTOINC_OLD_STYLE_LOCKING：在分配前加AUTO_INC锁，sql结束时释放。</li>
<li>AUTOINC_NEW_STYLE_LOCKING：默认模式，在普通的insert或replace时，通过加锁并预留本次需要的增长值后释放锁。否则退化到LOCK_AUTO_INC锁。（会浪费一些自增加ID，例如SQL中本身提供了ID值的情况）</li>
<li>AUTOINC_NO_LOCKING：分配时加mutex，不会退化到传统模式，但是不能保证statement方式下的复制安全性。</li>
</ol>
</li>
</ul>
<p>锁的兼容性如下：</p>
<table>
<thead>
<tr>
<th>&nbsp;</th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
<th>AI</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IS</strong></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td><strong>IX</strong></td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>✓</td>
<td>✗</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><strong>AI</strong></td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody></table>
<ul>
<li>GAP类型的锁申请（非插入意向锁），不需等待任何锁，GAP锁本身互不冲突。</li>
<li>任何锁请求都不需要等待插入意向锁。</li>
</ul>
<p><sub>注:DDL语句可以认为分为<em>准备，执行，提交</em>三个阶段。</sub></p>
<sub>
说明:
Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
如果Tx2在Tx1中间执行，对通过statement进行binlog记录时会导致主从不一致，不能保证id字段是一样的。
</sub>  

<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>锁的类型：</p>
<ol>
<li>LOCK_REC_NOT_GAP（记录锁）：只锁住对应的记录，不会锁记录之前的GAP。（RC隔离级别和唯一索引的RR级别一般加该锁）</li>
<li>LOCK_GAP（间隙锁）：只锁住一段空范围，通常是两个索引记录之间，或者是第一条记录之前，或者最后一条记录之后。（一般在RR隔离级别下会用到GAP锁）</li>
<li>LOCK_ORDINARY（NEXT_KEY_LOCK）：锁住记录和记录之前的间隙。</li>
</ol>
<p>锁的模式分为S锁和X锁：<br>S锁：共享锁，在以下场景中会增加S锁。</p>
<ul>
<li>在非自动提交并且隔离级别为serializable时，普通的select会加S锁。</li>
<li>select * from tablename for share model时会加S锁。<ul>
<li>RC隔离级别时：LOCK_REC_NOT_GAP|LOCK_S</li>
<li>RR隔离级别时：如果查询条件为唯一索引并且是唯一等值查询时加LOCK_REC_NOT_GAP|LOCK_S；非唯一索引或者查询会扫描多条记录时加LOCK_ORDINARY|LOCK_S锁，也就是记录本身和记录之前的GAP，以及下一条记录的GAP。</li>
</ul>
</li>
<li>通常insert操作不加锁，在插入时检查到duplicate key(或者有一个被标记为删除的duplicate key)，普通的insert会加LOCK_S锁，而REPLACE INTO 或者 INSERT … ON DUPLICATE的语句时加X锁。<ul>
<li>聚集索引，在小于等于RC隔离级别时加LOCK_REC_NOT_GAP类型的锁，否则加LOCK_ORDINARY模式的锁。</li>
<li>非聚集索引，默认应该和聚集索引一样，在5.7版本中总是加LOCK_ORDINARY类型的锁。</li>
</ul>
</li>
<li>外键检查，当删除一条父表上的记录时，需要检查是否有引用约束，会扫描子表上对应的记录，并加上S锁。<ul>
<li>如果被删除的值被子表引用，则子表加LOCK_REC_NOT_GAP|LOCK_S锁，并且一旦检查到就可以退出扫描，判断出错。</li>
<li>如果被删除的值没有被引用，则加LOCK_GAP|LOCK_S锁。（例外是被删除的值比子表对应的值都要大或者被扫描的记录标记为删除时加LOCK_ORDINARY|LOCK_S锁）</li>
</ul>
</li>
<li>insert … select 插入数据时，会对select的表上扫描到的数据加S锁[RC下不会加锁，RR下会加锁]。（同样update … where id in (select from b)时会对b表中的数据加S锁[RR和RC下都会加锁]）</li>
</ul>
<p><sub>说明：RC级别下一般只会锁住记录本身，RR级别下会锁住记录和记录前的间隙[唯一索引且是等值查询时例外，也只需要锁住记录即可，因为RR级别可以防止幻读]</sub></p>
<p>X锁：排他锁，在以下场景中加X锁。</p>
<ul>
<li>select … for update</li>
<li>update …</li>
<li>replace into</li>
<li>insert on duplicate key</li>
</ul>
<blockquote>
<p>插入意向锁是GAP锁的一种，多个插入意向锁之间不需要相互等待，在插入时会检查插入对象的下一条记录上是否有锁，如果下一条记录上存在锁，则需要判断该锁对象是否锁住了GAP，如果被锁住了，则需要等待。（RR隔离级别下通过GAP锁避免幻读）</p>
</blockquote>
<p><sub>说明：当通过主键进行更新时，会对主键上加锁，如果是通过二级索引进行更新时会对二级索引和主键索引都加锁，通过二级索引更新时二级索引RC级别下一般加LOCK_REC_NO_GAP锁（唯一索引例外），RR下对记录加LOCK_ORIDINAY锁并且对下一条记录加GAP锁，主键上加LOCK_REC_NO_GAP锁。加锁的过程为先扫描二级索引找到满足条件的数据，然后根据二级索引的内容[对应主键的值]查找主键对应的记录并加上锁。</sub></p>
<p><sub>说明：RC隔离级别下对不满足where条件的数据会被立刻释放掉[先加锁后释放，违法2PC原则]，但RR级别则会到事务结束才会释放。</sub></p>
<p>举例说明:</p>
<table>
<thead>
<tr>
<th>id</th>
<th>userid</th>
<th>pubtime</th>
<th>comment</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>hdc</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>yyy</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>hdc</td>
<td>5</td>
<td>good</td>
</tr>
<tr>
<td>1</td>
<td>hdc</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>bbb</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>hdc</td>
<td>100</td>
<td></td>
</tr>
<tr>
<td><sub>标注：id为主键，pubtime和userid为联合索引</sub></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在RC隔离级别下：delete from tablenam where pubtime &gt; 1 and pubtime &lt;20 and userid = ‘hdc’ and comment is not null;二级索引会对[5,hdc],<font color=red>[10,hdc]</font>的记录加X锁，主键索引会对[8],<font color=red>[1]</font>的记录加X锁，但是<font color=red>[10,hdc]和[1]</font>这个锁在事务结束前会被释放。（在index condition pushdown时二级索引的[3, yyy]这条记录不会加锁，对应的主键上的[4]也不会加锁,不支持ICP时这两条记录也会加锁。）</p>
<p>在RR隔离级别下：与RC隔离级别的区别为二级索引会加上GAP锁，并且<font color=red>[10,hdc]和[1]</font>锁在事务结束前不会释放。</p>
<p><sub>特例：ICP只有在通过索引能过滤数据时才能起作用，假如需要过滤的字段不在索引中则无法进行过滤，会加锁返回给server层。RC隔离级别有一定的优化，会提前释放不满足过滤条件的记录上的锁。</sub></p>
<blockquote>
<p>mysql中的MVCC通过回滚段实现，每一条数据有隐藏的字段指向之前的版本内容，另外存在快照读和当前读的区别，普通的select为快照读，但是对加x锁的读为当前读。因此在可重复读隔离级别下，select 和select for update读取到的数据是不一样的。</p>
</blockquote>
<h4 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h4><p>通过explain sql可以查看对应sql的执行计划，执行计划中各个字段含义如下。</p>
<pre>
<small>
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    3 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
</small>
</pre>


<ul>
<li><p>id：查询的序列号，表示查询中执行select子句或操作的顺序。id越大的优先级越高，越先执行，id相同的从上往下顺序执行。</p>
</li>
<li><p>select_type：查询的类型，用于区分普通查询，联合查询，子查询等复杂的查询。</p>
<ul>
<li>SIMPLE：简单的select查询，查询中不包含子查询和union。</li>
<li>PRIMARY：查询中包含任何复杂的查询时，最外层查询被标记为primary(例如select中有子查询，或者from中有子查询)。</li>
<li>SUBQUERY：在select或where列表中包含了子查询。</li>
<li>DERIVED：在from列表中包含的子查询被标记为derived，mysql或递归执行这些子查询，把结果放在临时表里。</li>
<li>UNION：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为derived。</li>
<li>UNION RESULT：从union表获取结果的select</li>
</ul>
</li>
<li><p>type：访问类型，sql查询优化中很重要的指标，mysql决定如何查找表中的行，从好到坏依次是<strong>system</strong>&gt;<strong>const</strong>&gt;<strong>eq_ref</strong>&gt;<strong>ref</strong>&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;<br><strong>range</strong>&gt;<strong>index</strong>&gt;<strong>ALL</strong></p>
<ul>
<li>system：表示只有一行记录，是const类型的特例。例如select * from （select * from tablename where primarykey = 1），则最外面查询的访问类型为system，这种类型的访问类型一般不会出现。</li>
<li>const：表示通过索引一次就找到了，用于主键和唯一索引中，因为只需要匹配一行数据，所以很快(唯一索引中的等于查询，有多个值时会变成range即使走的是唯一索引)。</li>
<li>eq_ref：唯一索引扫描，对于每一个索引键，表中只有一条记录与之匹配，常见于两个表通过唯一索引关联时。</li>
<li>ref：非唯一性索引扫描，返回匹配某个<strong>单值</strong>的所有行。</li>
<li>range：只检索给定范围的行，使用一个索引来选择，key列显示用来哪个索引。一般在where语句中出现了between，&lt;,&gt;,in等的查询中，这种索引列上的范围比全索引扫描要好。</li>
<li>index：全索引扫描，与ALL的区别为index类型只需要遍历索引树。例如explain select id from tablename。</li>
<li>ALL：全表扫描。</li>
</ul>
</li>
<li><p>possible_keys：查询涉及到的字段上存在的索引，则对应的索引会被列出，但不一定被查询实际使用。</p>
</li>
<li><p>key：实际使用的索引，如果为NULL，则没有使用索引。<strong>查询中如果使用了覆盖索引（所有的字段都能从索引中获取），则该索引仅出现在key列表中</strong></p>
</li>
<li><p>key_len：表示索引中使用的字节数，查询中使用的索引长度，非实际使用的长度，理论上长度越短越好。[length计算规则，char(n)n字节，varchar(n)如果为utf-8则为3n+2,tinyint 1字节，smallint 2字节， int 4字节， bigint 8字节， date 3字节，timestamp 4字节，datetime 8字节，如果字段允许为null 需要1字节记录是否为null，单列索引最大长度为767字节，可以通过innodb_large_prefix最大调整到3072字节，并且加上row_format=compressed或者dynamic，联合索引最长为3072字节，与innodb默认为16k有关系]</p>
</li>
<li><p>ref：显示key列索引中，表查找值所用到的列(关联的字段)或常量(const)。</p>
</li>
<li><p>rows：根据表统计信息及索引使用情况，大致估算出找到所需记录所需要读取的行数。</p>
</li>
<li><p>Extra：十分重要的额外信息。</p>
<ul>
<li>Using filesort：对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。通常在order by并且与索引中字段的顺序不一致时。</li>
<li>Using temporary：使用临时表保存中间结果，常见于order by，group by和distinct中。</li>
<li>Using index：表示相应的select操作使用了<strong>覆盖索引</strong>，避免了访问表的数据行，如果同时出现Using where，表示索引被用来执行索引键值的查找，如果没有出现Using where，表示索引用来读取数据而不是执行查找动作。</li>
</ul>
<p><sub>提示：覆盖索引中可以包括主键，因为辅助索引的值为主键</sub></p>
<ul>
<li>Using where：使用了where过滤</li>
<li>Using join buffer：使用了链接缓存</li>
<li>Impossible Where：表示where总是为false，获取不到任何数据</li>
<li>select tables optimized away：在没有group by子句的情况下，基于索引优化的min、max操作，不必等到执行阶段再进行计算，查询执行计划生成时就可以完成优化。</li>
<li>distinct：优化distinc操作，在找到第一个匹配的元组后停止找同样值的动作。</li>
</ul>
</li>
</ul>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ul>
<li>两个参数至少一个是NULL时，比较的结果也是NULL。例外是使用*&lt;=&gt;*对两个NULL做比较时返回1，这两种情况下都不需要做类型转换。</li>
<li>两个参数都是字符串，按照字符串来比较，不做类型转换。</li>
<li>两个参数都是整数，按照整数来比较，不做类型转换。</li>
<li>十六进制的值和非数字做比较时，被当做二进制串。</li>
<li>有一个参数是TIMESTAP或DATETIME，并且另外一个参数是常量，常量会被转换为timestamp。</li>
<li>有一个参数是decimal类型，如果另外一个参数是decimal或者整数，将整数转换为decimal后进行比较。如果另外一个是浮点数，将decimal转换为浮点数进行比较。</li>
<li>所有其他情况下，两个参数都会被转换为浮点数进行比较。</li>
</ul>
<p><sub>注意：如果字段的字符集不一样也会导致索引失效，例如一个表用的utf8，另外一个表用utf8mb4。</sub></p>
<blockquote>
<p>explain extended 会在explain的基础上额外提供一些查询优化信息，紧随其后通过show warnings可以得到优化后的查询语句。还会有一个filtered列，是一个半分比的值，rows*filtered/100可以估算出和前一个表进行连接的行数。<br>explain partitions 如果是分区表，则会显示查询将访问的分区。<br>order by ,group by尽量用到索引，并且按照索引创建的顺序进行排序（匹配最左原则）。group by会先进行排序因此与order by一样，理论上group by的值和字段的顺序没关系，但是mysql也不会自动调整字段顺序以便走索引。（最左前缀匹配在oracle中还支持INDEX SKIP SCAN，当第一个字段的值只有几种类型时也可能会优化走索引）</p>
</blockquote>
<h4 id="in和exists的区别"><a href="#in和exists的区别" class="headerlink" title="in和exists的区别"></a>in和exists的区别</h4><p>sql表关联时的原则是小表驱动大表，尽量使外循环的数据量少，因为一般关联时会建立索引，因此在10万条数据中找1条数据和在1万条数据中找1条数据区别不大。因此当外循环数据少时速度更快。<br>以下两个sql返回值是一样的，只是写法不一样，一种用in一种用exists。</p>
<ol>
<li>select * from table_a a where a.id in (<em>select id from table_b b</em>);</li>
<li>*select * from table_a* a where exists (select 1 from table_b b where b.id = a.id);</li>
</ol>
<p>不同之处是红色字体的语句会先执行，因此当table_a比table_b数据量大很多时 in会效率高，反过来时exists高。</p>
<h3 id="left-join-时-on和where的区别"><a href="#left-join-时-on和where的区别" class="headerlink" title="left join 时 on和where的区别"></a>left join 时 on和where的区别</h3><p>假如有actor和film_actor两个表，表的数据如下：</p>
<pre>
select * from actor;
+----+------+---------------------+
| id | name | update_time         |
+----+------+---------------------+
|  1 | a    | 2017-12-22 15:27:18 |
|  2 | b    | 2017-12-22 15:27:18 |
|  3 | c    | 2017-12-22 15:27:18 |
+----+------+---------------------+
</pre>
<pre>
select * from film_actor;
+----+---------+----------+--------+
| id | film_id | actor_id | remark |
+----+---------+----------+--------+
|  1 |       1 |        1 | NULL   |
|  2 |       1 |        2 | NULL   |
|  3 |       2 |        1 | NULL   |
+----+---------+----------+--------+
</pre>
<pre>
select * from actor a left join film_actor f on a.id = f.actor_id;
+----+------+---------------------+------+---------+----------+--------+
| id | name | update_time         | id   | film_id | actor_id | remark |
+----+------+---------------------+------+---------+----------+--------+
|  1 | a    | 2017-12-22 15:27:18 |    1 |       1 |        1 | NULL   |
|  2 | b    | 2017-12-22 15:27:18 |    2 |       1 |        2 | NULL   |
|  1 | a    | 2017-12-22 15:27:18 |    3 |       2 |        1 | NULL   |
|  3 | c    | 2017-12-22 15:27:18 | NULL |    NULL |     NULL | NULL   |
+----+------+---------------------+------+---------+----------+--------+
</pre>

<pre>
select * from actor a left join film_actor f on a.id = f.actor_id  and a.name = 'a';
+----+------+---------------------+------+---------+----------+--------+
| id | name | update_time         | id   | film_id | actor_id | remark |
+----+------+---------------------+------+---------+----------+--------+
|  1 | a    | 2017-12-22 15:27:18 |    1 |       1 |        1 | NULL   |
|  1 | a    | 2017-12-22 15:27:18 |    3 |       2 |        1 | NULL   |
|  2 | b    | 2017-12-22 15:27:18 | NULL |    NULL |     NULL | NULL   |
|  3 | c    | 2017-12-22 15:27:18 | NULL |    NULL |     NULL | NULL   |
+----+------+---------------------+------+---------+----------+--------+
</pre>
<pre>
select * from actor a left join film_actor f on a.id = f.actor_id  where a.name = 'a';
+----+------+---------------------+------+---------+----------+--------+
| id | name | update_time         | id   | film_id | actor_id | remark |
+----+------+---------------------+------+---------+----------+--------+
|  1 | a    | 2017-12-22 15:27:18 |    1 |       1 |        1 | NULL   |
|  1 | a    | 2017-12-22 15:27:18 |    3 |       2 |        1 | NULL   |
+----+------+---------------------+------+---------+----------+--------+
</pre>

<small>
由上面的结果可知left join 时where和on是有区别的，因为left join时左表的数据是需要都显示出来的，因此on条件只会影响哪些数据需要和右表关联，但是不会对结果数据进行过滤，如果需要过滤数据需要用where。
</small>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/22/2019-09-22-Java%E4%B8%8E%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mountain.jpg">
      <meta itemprop="name" content="wjainng">
      <meta itemprop="description" content="学而不思则罔思而不学则殆">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WJAINNG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/22/2019-09-22-Java%E4%B8%8E%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Java与模式-创建模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-22 22:21:59" itemprop="dateCreated datePublished" datetime="2019-09-22T22:21:59+08:00">2019-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-16 23:15:44" itemprop="dateModified" datetime="2020-09-16T23:15:44+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h1><blockquote>
<p>创建模式是对类的实例化过程的抽象化。</p>
</blockquote>
<ul>
<li>类的创建模式：把类的创建延迟到子类，从而封装了客户端将得到哪些具体类的信息，并且隐藏了这些类的实例是如何被创建和放在一起的。</li>
<li>对象的创建模式：把对象的创建过程动态地委派给另一个对象，从而动态地决定客户端将得到哪些具体类的实例，以及这些类的实例是如何被创建和组合在一起的。</li>
</ul>
<h2 id="简单工厂模式（Simple-Factory"><a href="#简单工厂模式（Simple-Factory" class="headerlink" title="简单工厂模式（Simple Factory)"></a>简单工厂模式（Simple Factory)</h2><blockquote>
<p>简单工厂模式是类的创建模式，又叫做静态工厂方法模式，由一个工厂对象决定创建出哪一种产品类的实例。</p>
</blockquote>
<p><strong>优点：</strong><br>简单，一个工厂类处理所有产品的实例化，客户端相对独立于产品创建过程，一定程度上支持开闭原则。<br><strong>缺点：</strong><br>针对抽象产品有多个时不能很好地处理，并且只要有新的具体产品就需要修改工厂类。</p>
<p><strong>类图</strong><br><img src="/images/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂"></p>
<h2 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h2><blockquote>
<p>工厂方法模式是类的创建模式，定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wjainng"
      src="/images/mountain.jpg">
  <p class="site-author-name" itemprop="name">wjainng</p>
  <div class="site-description" itemprop="description">学而不思则罔思而不学则殆</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wjainng</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
